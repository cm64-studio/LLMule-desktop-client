
--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/auth/handlers.js ---
import { ipcMain } from 'electron'
import axios from 'axios'
import Store from 'electron-store'
import config from '../config.js'

const store = new Store()

// Create axios instance with default config
const api = axios.create({
  baseURL: config.API_URL,
  timeout: 10000,
})

// Add request interceptor to log requests
api.interceptors.request.use(config => {
  console.log(`Making request to ${config.url} with baseURL ${config.baseURL}`)
  return config
})

// Add response interceptor to log responses
api.interceptors.response.use(
  response => {
    console.log(`Response from ${response.config.url}:`, response.status)
    return response
  },
  error => {
    console.error('API Error:', error.response?.data || error.message)
    throw error
  }
)

export function setupAuthHandlers() {
  ipcMain.handle('auth:register', async (_, email) => {
    try {
      const response = await api.post('/auth/register', { email })
      return response.data
    } catch (error) {
      console.error('Registration failed:', error.response?.data || error.message)
      throw new Error(error.response?.data?.message || 'Registration failed')
    }
  })

  ipcMain.handle('auth:checkVerification', async () => {
    try {
      const apiKey = store.get('apiKey')
      const response = await api.get('/auth/me', {
        headers: { Authorization: `Bearer ${apiKey}` }
      })
      return response.data.verified === true
    } catch (error) {
      console.error('Verification check failed:', error.response?.data || error.message)
      return false
    }
  })

  ipcMain.handle('auth:getStatus', async () => {
    const apiKey = store.get('apiKey')
    if (!apiKey) return { authenticated: false }

    try {
      const response = await api.get('/auth/me', {
        headers: { Authorization: `Bearer ${apiKey}` }
      })
      console.log('Auth status response:', response.data)
      
      return {
        authenticated: true,
        user: response.data
      }
    } catch (error) {
      console.error('Auth status check failed:', error.response?.data || error.message)
      return { authenticated: false }
    }
  })

  ipcMain.handle('auth:getBalance', async () => {
    const apiKey = store.get('apiKey')
    if (!apiKey) return { mule_balance: 0 }

    try {
      console.log('Fetching balance from:', `${config.API_URL}/v1/balance`)
      const response = await api.get('/v1/balance', {
        headers: { 
          Authorization: `Bearer ${apiKey}`,
          'Accept': 'application/json'
        }
      })
      console.log('Raw balance response:', response.data)
      return response.data
    } catch (error) {
      console.error('Balance check failed:', error.response?.data || error.message)
      if (error.response) {
        console.error('Error status:', error.response.status)
        console.error('Error headers:', error.response.headers)
      }
      return { mule_balance: 0 }
    }
  })
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/config.js ---
const config = {
  development: {
    API_URL: 'http://localhost:3000',
    WS_URL: 'ws://localhost:3000/llm-network'
  },
  production: {
    API_URL: 'https://api.llmule.xyz',
    WS_URL: 'wss://api.llmule.xyz/llm-network'
  }
}

// Force production environment by default
const env = 'development'
console.log('Current environment:', env, 'using API:', config[env].API_URL)
export default config[env]

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/llm/clients.js ---
import axios from 'axios';

class LLMClient {
  async generateCompletion(model, messages, options = {}) {
    throw new Error('Method not implemented');
  }
}

export class OllamaClient extends LLMClient {
  async generateCompletion(model, messages, options = {}) {
    try {
      const response = await axios.post('http://localhost:11434/api/chat', {
        model,
        messages,
        stream: false,
        options: {
          temperature: options.temperature || 0.7,
          num_predict: options.max_tokens || 4096,
        }
      });

      const usage = {
        prompt_tokens: this._estimateTokenCount(messages),
        completion_tokens: this._estimateTokenCount([response.data.message]),
        total_tokens: 0
      };
      usage.total_tokens = usage.prompt_tokens + usage.completion_tokens;

      return {
        choices: [{
          message: {
            role: 'assistant',
            content: response.data.message.content
          },
          finish_reason: 'stop'
        }],
        usage
      };
    } catch (error) {
      throw new Error(`Ollama error: ${error.message}`);
    }
  }

  _estimateTokenCount(messages) {
    let totalChars = 0;
    messages.forEach(msg => {
      if (typeof msg === 'string') totalChars += msg.length;
      else if (msg.content) totalChars += msg.content.length;
    });
    return Math.ceil(totalChars / 4);
  }
}

export class LMStudioClient extends LLMClient {
  async generateCompletion(model, messages, options = {}) {
    try {
      const response = await axios.post(
        'http://localhost:1234/v1/chat/completions',
        {
          model,
          messages,
          temperature: options.temperature || 0.7,
          max_tokens: options.max_tokens || 4096,
          stream: false
        }
      );

      return {
        choices: response.data.choices,
        usage: response.data.usage || {
          prompt_tokens: 0,
          completion_tokens: 0,
          total_tokens: 0
        }
      };
    } catch (error) {
      throw new Error(`LM Studio error: ${error.message}`);
    }
  }
}

export class ExoClient extends LLMClient {
  async generateCompletion(model, messages, options = {}) {
    try {
      const response = await axios.post(
        'http://localhost:52415/v1/chat/completions',
        {
          model,
          messages,
          temperature: options.temperature || 0.7,
          max_tokens: options.max_tokens || 4096,
          stream: false
        }
      );

      return {
        choices: response.data.choices,
        usage: response.data.usage || {
          prompt_tokens: 0,
          completion_tokens: 0,
          total_tokens: 0
        }
      };
    } catch (error) {
      throw new Error(`EXO error: ${error.message}`);
    }
  }
}

export class VLLMClient extends LLMClient {
  async generateCompletion(model, messages, options = {}) {
    try {
      const response = await axios.post(
        'http://localhost:8000/v1/chat/completions',
        {
          model,
          messages,
          temperature: options.temperature || 0.7,
          max_tokens: options.max_tokens || 4096,
          stream: false
        }
      );

      return {
        choices: response.data.choices,
        usage: response.data.usage || {
          prompt_tokens: 0,
          completion_tokens: 0,
          total_tokens: 0
        }
      };
    } catch (error) {
      throw new Error(`vLLM error: ${error.message}`);
    }
  }
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/llm/detector.js ---
import axios from 'axios'
import Store from 'electron-store'

const store = new Store()

export class ModelDetector {
  constructor() {
    this.config = {
      ollama: 'http://localhost:11434',
      lmstudio: 'http://localhost:1234/v1',
      exo: 'http://localhost:52415',
      vllm: 'http://localhost:8000/v1'
    }
    console.log('ModelDetector initialized with config:', this.config);
  }

  async detectAll() {
    console.log('Starting detectAll...');
    const services = await this.checkServices()
    console.log('Available services:', services);
    const models = []

    if (services.ollama) {
      console.log('Detecting Ollama models...');
      const ollamaModels = await this.detectOllamaModels()
      console.log('Found Ollama models:', ollamaModels);
      models.push(...ollamaModels)
    }

    if (services.lmstudio) {
      console.log('Detecting LM Studio models...');
      const lmstudioModels = await this.detectLMStudioModels()
      console.log('Found LM Studio models:', lmstudioModels);
      models.push(...lmstudioModels)
    }

    if (services.exo) {
      console.log('Detecting EXO models...');
      const exoModels = await this.detectExoModels()
      console.log('Found EXO models:', exoModels);
      models.push(...exoModels)
    }

    if (services.vllm) {
      console.log('Detecting vLLM models...');
      const vllmModels = await this.detectVLLMModels()
      console.log('Found vLLM models:', vllmModels);
      models.push(...vllmModels)
    }

    console.log('Total models detected:', models);
    return models
  }

  async checkServices() {
    console.log('Checking services availability...');
    const services = {}
    for (const [name, url] of Object.entries(this.config)) {
      try {
        console.log(`Checking ${name} at ${url}...`);
        await axios.get(url)
        console.log(`${name} is available`);
        services[name] = true
      } catch (error) {
        console.log(`${name} is not available:`, error.message);
        services[name] = false
      }
    }
    return services
  }

  async detectOllamaModels() {
    try {
      console.log('Fetching Ollama models from:', `${this.config.ollama}/api/tags`);
      const response = await axios.get(`${this.config.ollama}/api/tags`)
      console.log('Ollama response:', response.data);
      return response.data.models.map(model => ({
        name: model.name,
        type: 'ollama',
        details: model
      }))
    } catch (error) {
      console.log('Failed to detect Ollama models:', error.message);
      return []
    }
  }

  async detectLMStudioModels() {
    try {
      console.log('Fetching LM Studio models from:', `${this.config.lmstudio}/models`);
      const response = await axios.get(`${this.config.lmstudio}/models`)
      console.log('LM Studio response:', response.data);
      return response.data.data.map(model => ({
        name: model.id,
        type: 'lmstudio'
      }))
    } catch (error) {
      console.log('Failed to detect LM Studio models:', error.message);
      return []
    }
  }

  async detectExoModels() {
    try {
      console.log('Fetching EXO models from:', `${this.config.exo}/v1/models`);
      const response = await axios.get(`${this.config.exo}/v1/models`)
      console.log('EXO response:', response.data);
      return response.data.data.map(model => ({
        name: model.id,
        type: 'exo'
      }))
    } catch (error) {
      console.log('Failed to detect EXO models:', error.message);
      return []
    }
  }

  async detectVLLMModels() {
    try {
      console.log('Fetching vLLM models from:', `${this.config.vllm}/models`);
      const response = await axios.get(`${this.config.vllm}/models`)
      console.log('vLLM response:', response.data);
      return response.data.data.map(model => ({
        name: model.id,
        type: 'vllm'
      }))
    } catch (error) {
      console.log('Failed to detect vLLM models:', error.message);
      return []
    }
  }
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/llm/handlers.js ---
import { ipcMain } from 'electron'
import { ModelDetector } from './detector'
import { NetworkClient } from './network'

let networkClient = null;
const detector = new ModelDetector();

export function setupLLMHandlers() {
  ipcMain.handle('llm:detect', async () => {
    return await detector.detectAll();
  });

  ipcMain.handle('llm:connect', async (_, models) => {
    try {
      if (!networkClient) networkClient = new NetworkClient();
      if (!models || !models.length) {
        throw new Error('No models provided for connection');
      }
      await networkClient.connect(models);
      return { success: true };
    } catch (error) {
      console.error('Connection failed:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('llm:disconnect', async () => {
    try {
      if (networkClient) {
        await networkClient.disconnect();
        networkClient = null;
      }
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  });
}

function sendToRenderer(channel, data) {
  if (global.mainWindow) {
    global.mainWindow.webContents.send(channel, data)
  }
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/llm/network.js ---
import WebSocket from 'ws'
import axios from 'axios'
import config from '../config'
import { OllamaClient, LMStudioClient, ExoClient, VLLMClient } from './clients'
import Store from 'electron-store'

const store = new Store()

export class NetworkClient {
    constructor() {
      this.ws = null;
      this.isConnected = false;
      this.lastPong = Date.now();
      this.heartbeatInterval = null;
      this.reconnectAttempts = 0;
      this.maxReconnectAttempts = 5;
      this.models = [];
      this.shouldReconnect = true;
      this.reconnectDelay = 5000;
    }

  async getUserInfo() {
    try {
      const apiKey = store.get('apiKey');
      const response = await axios.get(`${config.API_URL}/auth/me`, {
        headers: { 
          'Authorization': `Bearer ${apiKey}`,
          'Accept': 'application/json'
        }
      });
      return response.data;
    } catch (error) {
      console.error('Failed to get user info:', error);
      return null;
    }
  }

  setupHeartbeat() {
    if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);

    // Add keepalive ping
    this.ws.on('ping', () => {
      try {
        this.ws.pong();
        this.lastPong = Date.now();
      } catch (error) {
        console.error('Error sending pong:', error);
        this.reconnect();
      }
    });

    this.ws.on('pong', () => {
      this.lastPong = Date.now();
    });

    // More aggressive connection monitoring
    this.heartbeatInterval = setInterval(() => {
      if (Date.now() - this.lastPong > 45000) {
        console.log('Connection dead - reconnecting...');
        this.reconnect();
      }
      
      // Actively test connection
      if (this.ws.readyState === WebSocket.OPEN) {
        try {
          this.ws.ping();
        } catch (error) {
          console.error('Ping failed:', error);
          this.reconnect();
        }
      }
    }, 15000);
  }

  async connect(models) {
    if (!this.shouldReconnect) {
      console.log('Connection cancelled - shutdown in progress');
      return;
    }

    const apiKey = store.get('apiKey');
    if (!apiKey) throw new Error('No API key found');
    
    this.models = models;
    this.ws = new WebSocket(config.WS_URL, {
      headers: { 'Authorization': `Bearer ${apiKey}` }
    });

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        this.ws.terminate();
        reject(new Error('Connection timeout'));
      }, 15000);

      this.ws.on('open', async () => {
        clearTimeout(timeout);
        this.isConnected = true;
        // Notify UI
        if (global.mainWindow) {
            global.mainWindow.webContents.send('llm:status', { connected: true });
        }
        this.reconnectAttempts = 0;
        this.setupHeartbeat();
        
        try {
          await this.register(models);
          resolve();
        } catch (error) {
          reject(error);
        }
      });

      this.ws.on('message', this.handleMessage.bind(this));
      
      this.ws.on('close', async (code) => {
        this.isConnected = false;
        clearInterval(this.heartbeatInterval);
        
        // Notify UI
        if (global.mainWindow) {
          global.mainWindow.webContents.send('llm:status', { connected: false });
        }
    
        if (code !== 1000 && this.shouldReconnect) {
          await this.reconnect();
        }
      });

      this.ws.on('error', async (error) => {
        console.error('WebSocket error:', error);
        await this.reconnect();
        reject(error);
      });
    });
  }

  async register(models) {
    try {
      const userInfo = await this.getUserInfo();
      if (!userInfo?.userId) throw new Error('Failed to get user info');

      const modelList = models || this.models || [];
      const apiKey = store.get('apiKey');

      if (!modelList.length) {
        console.error('No models available for registration');
        return;
      }

      const message = {
        type: 'register',
        apiKey: apiKey,
        models: modelList.map(m => m.name),
        userId: userInfo.userId,
        provider: userInfo.provider
      };

      console.log('Sending registration:', JSON.stringify({
        type: message.type,
        models: message.models,
        userId: message.userId,
        hasApiKey: !!message.apiKey
      }));

      this.ws.send(JSON.stringify(message));
    } catch (error) {
      console.error('Failed to register:', error);
    }
  }

  async handleMessage(data) {
    const message = JSON.parse(data);
    console.log('Received message:', message.type);

    switch (message.type) {
      case 'completion_request':
        await this.handleCompletionRequest(message);
        break;
      case 'registered':
        console.log('Successfully registered');
        break;
      case 'error':
        console.error('Server error:', message.error);
        break;
    }
  }

  async handleCompletionRequest(message) {
    const llmClients = {
      ollama: new OllamaClient(),
      lmstudio: new LMStudioClient(),
      exo: new ExoClient(),
      vllm: new VLLMClient()
    };

    try {
      const model = this.models.find(m => m.name === message.model);
      if (!model) {
        throw new Error(`Model ${message.model} not available`);
      }

      // Log activity start
      if (global.mainWindow) {
        global.mainWindow.webContents.send('llm:activity', {
          type: 'completion_start',
          message: `Processing request for ${model.name}`,
          timestamp: Date.now()
        });
      }

      const client = llmClients[model.type];
      const response = await client.generateCompletion(
        model.name,
        message.messages,
        {
          temperature: message.temperature,
          max_tokens: message.max_tokens
        }
      );

      // Log successful completion
      if (global.mainWindow) {
        global.mainWindow.webContents.send('llm:activity', {
          type: 'completion_success',
          message: `Completed request for ${model.name}`,
          timestamp: Date.now(),
          tokens: response.usage
        });
      }

      this.ws.send(JSON.stringify({
        type: 'completion_response',
        requestId: message.requestId,
        response
      }));

    } catch (error) {
      // Log error
      if (global.mainWindow) {
        global.mainWindow.webContents.send('llm:activity', {
          type: 'completion_error',
          message: `Error: ${error.message}`,
          timestamp: Date.now()
        });
      }

      this.ws.send(JSON.stringify({
        type: 'completion_response',
        requestId: message.requestId,
        response: {
          error: {
            message: error.message,
            type: "provider_error",
            code: "completion_failed"
          }
        }
      }));
    }
  }

  async disconnect() {
    await this.cleanup();
  }

  async reconnect() {
    if (!this.shouldReconnect) return;
  
    this.reconnectAttempts++;
    console.log(`Reconnecting (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
    
    try {
      await new Promise(r => setTimeout(r, this.reconnectDelay));
      await this.connect(this.models);
      this.reconnectAttempts = 0;
    } catch (error) {
      console.error('Reconnection failed:', error);
      
      // Reset and try again if max attempts reached
      if (this.reconnectAttempts >= this.maxReconnectAttempts) {
        console.log('Max attempts reached - resetting counter and continuing...');
        this.reconnectAttempts = 0;
        await new Promise(r => setTimeout(r, 10000)); // Longer delay before reset
        this.reconnect();
      }
    }
  }


  async cleanup() {
    console.log('Cleaning up...');
    this.shouldReconnect = false;

    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
    }

    if (this.ws) {
      try {
        if (this.ws.readyState === WebSocket.OPEN) {
          await new Promise((resolve) => {
            this.ws.send(JSON.stringify({
              type: 'disconnect',
              message: 'Client shutting down'
            }), resolve);
          });
        }
        this.ws.terminate();
      } catch (error) {
        console.error('Cleanup error:', error);
      }
    }

    this.isConnected = false;
    await new Promise(r => setTimeout(r, 500));
  }
  
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/main.js ---
import { app, BrowserWindow, ipcMain } from 'electron'
import path from 'path'
import Store from 'electron-store'
import { setupAuthHandlers } from './auth/handlers.js'
import { setupLLMHandlers } from './llm/handlers.js'
import config from './config.js'
import { fileURLToPath } from 'url'


const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Environment setup
process.env.NODE_ENV = process.env.NODE_ENV || 'development'
process.env.API_URL = config.API_URL
process.env.WS_URL = config.WS_URL
console.log('Using API URL:', process.env.API_URL)
console.log('Using WS URL:', process.env.WS_URL)

const store = new Store()
let mainWindow = null
// Add this function before createWindow
function getIconPath() {
  if (process.platform === 'darwin') {
    return path.join(process.resourcesPath, 'assets', 'icon.icns')
  }
  return path.join(process.resourcesPath, 'assets', 'icon.png')
}

const createWindow = () => {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    icon: getIconPath(),
    show: false,
    backgroundColor: '#111827',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    }
  })

  mainWindow.once('ready-to-show', () => {
    mainWindow.show()
  })

  if (process.env.VITE_DEV_SERVER_URL) {
    mainWindow.loadURL(process.env.VITE_DEV_SERVER_URL)
    mainWindow.webContents.openDevTools()
  } else {
    mainWindow.loadFile('dist/index.html')
  }

  global.mainWindow = mainWindow
}

app.whenReady().then(() => {
  createWindow()
  setupAuthHandlers()
  setupLLMHandlers()
  
  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit()
})

// IPC Handlers
ipcMain.handle('store:get', (_, key) => {
  return store.get(key)
})

ipcMain.handle('store:set', (_, key, value) => {
  store.set(key, value)
  return true
})

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/preload.js ---
const { contextBridge, ipcRenderer } = require('electron')

// Use environment variables set from config.js
const config = {
  API_URL: process.env.API_URL || 'http://localhost:3000',
  WS_URL: process.env.WS_URL || 'ws://localhost:3000/llm-network'
}

// Set up activity event listener
let activityCallback = null;
ipcRenderer.on('llm:activity', (_, data) => {
  if (activityCallback) activityCallback(data);
});

contextBridge.exposeInMainWorld('electron', {
  config,
  store: {
    get: (key) => ipcRenderer.invoke('store:get', key),
    set: (key, value) => ipcRenderer.invoke('store:set', key, value),
  },
  auth: {
    register: (email) => ipcRenderer.invoke('auth:register', email),
    checkVerification: () => ipcRenderer.invoke('auth:checkVerification'),
    getStatus: () => ipcRenderer.invoke('auth:getStatus'),
    getBalance: () => ipcRenderer.invoke('auth:getBalance')
  },
  llm: {
    detectServices: () => ipcRenderer.invoke('llm:detect'),
    getModels: () => ipcRenderer.invoke('llm:models'),
    connect: (models) => ipcRenderer.invoke('llm:connect', models),
    disconnect: () => ipcRenderer.invoke('llm:disconnect'),
    onActivity: (callback) => {
      activityCallback = callback;
    },
    onStatus: (callback) => {
      ipcRenderer.on('llm:status', (_, data) => callback(data));
    }
  }
})

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/tray.js ---
import { Tray, Menu, app } from 'electron'
import path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

export class SystemTray {
  constructor(window) {
    this.window = window
    this.tray = null
  }

  create() {
    this.tray = new Tray(path.join(__dirname, '../assets/tray-icon.png'))
    this.tray.setToolTip('LLMule Desktop')
    this.updateMenu()
  }

  updateMenu(isConnected = false) {
    const contextMenu = Menu.buildFromTemplate([
      { label: 'LLMule Desktop', enabled: false },
      { type: 'separator' },
      {
        label: isConnected ? 'Stop Sharing' : 'Start Sharing',
        click: () => {
          this.window.webContents.send('tray:toggle-sharing')
        }
      },
      { type: 'separator' },
      {
        label: 'Show Window',
        click: () => {
          this.window.show()
        }
      },
      {
        label: 'Quit',
        click: () => {
          app.quit()
        }
      }
    ])

    this.tray.setContextMenu(contextMenu)
  }

  destroy() {
    if (this.tray) {
      this.tray.destroy()
    }
  }
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/updater.js ---
import { autoUpdater } from 'electron-updater'
import { dialog } from 'electron'

export function setupAutoUpdater(window) {
  autoUpdater.autoDownload = false
  
  autoUpdater.on('error', (error) => {
    dialog.showErrorBox('Error', error.message)
  })

  autoUpdater.on('update-available', async () => {
    const response = await dialog.showMessageBox({
      type: 'info',
      title: 'Update Available',
      message: 'A new version of LLMule Desktop is available. Would you like to download it now?',
      buttons: ['Yes', 'No']
    })

    if (response.response === 0) {
      autoUpdater.downloadUpdate()
    }
  })

  autoUpdater.on('update-downloaded', async () => {
    const response = await dialog.showMessageBox({
      type: 'info',
      title: 'Update Ready',
      message: 'Install the update now?',
      buttons: ['Yes', 'Later']
    })

    if (response.response === 0) {
      autoUpdater.quitAndInstall()
    }
  })

  // Check for updates
  autoUpdater.checkForUpdates()
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/eslint.config.js ---
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]


--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/package.json ---
{
  "name": "llmule-desktop",
  "private": true,
  "version": "0.0.1",
  "description": "LLMule Desktop - Decentralized AI Computing",
  "author": {
    "name": "Andrés Cufari",
    "email": "andres@cm64.studio"
  },
  "type": "module",
  "main": "dist-electron/main.js",
  "scripts": {
    "dev": "vite",
    "start": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "electron:dev": "vite build && electron .",
    "electron:build": "electron-builder build --mac --config electron-builder.json",
    "package:mac": "npm run build && npm run electron:build",
    "package:mac-arm64": "npm run build && electron-builder build --mac --arm64 --config electron-builder.json",
    "package:mac-x64": "npm run build && electron-builder build --mac --x64 --config electron-builder.json",
    "package:mac-universal": "npm run build && electron-builder build --mac --universal --config electron-builder.json",
    "package:linux": "npm run build && electron-builder build --linux --config electron-builder.json",
    "package:win": "npm run build && electron-builder build --win --config electron-builder.json"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.0",
    "@heroicons/react": "^2.2.0",
    "@tailwindcss/typography": "^0.5.10",
    "autoprefixer": "^10.4.20",
    "axios": "^1.7.9",
    "bufferutil": "^4.0.9",
    "electron-store": "^10.0.0",
    "electron-updater": "^6.3.9",
    "postcss": "^8.4.49",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hot-toast": "^2.5.1",
    "react-markdown": "^9.0.1",
    "react-syntax-highlighter": "^15.5.0",
    "remark-gfm": "^4.0.0",
    "tailwindcss": "^3.4.17",
    "utf-8-validate": "^6.0.5",
    "uuid": "^11.0.5",
    "vite-plugin-electron": "^0.29.0",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "concurrently": "^9.1.2",
    "electron": "^33.2.1",
    "electron-builder": "^25.1.8",
    "eslint": "^9.17.0",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "vite": "^6.0.5",
    "wait-on": "^8.0.1"
  }
}


--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/postcss.config.js ---
import tailwindcss from 'tailwindcss'
import autoprefixer from 'autoprefixer'

export default {
  plugins: {
    tailwindcss,
    autoprefixer,
  },
}


--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/App.jsx ---
import React, { useState, useEffect } from 'react'
import { Toaster } from 'react-hot-toast'
import { NetworkProvider } from './contexts/NetworkContext'
import { ChatProvider } from './contexts/ChatContext'
import MainLayout from './components/layouts/MainLayout'
import StatusBar from './components/StatusBar'
import ModelList from './components/ModelList'
import ActivityLog from './components/ActivityLog'
import NetworkStats from './components/NetworkStats'
import AuthScreen from './components/auth/AuthScreen'
import ChatView from './components/chat/ChatView'
import { ChatBubbleLeftRightIcon, ShareIcon } from '@heroicons/react/24/outline'

function App() {
  const [authStatus, setAuthStatus] = useState({ loading: true, authenticated: false })
  const [activeView, setActiveView] = useState('chat') // 'chat' or 'network'

  useEffect(() => {
    checkAuth()
    // Hide splash screen once React app is mounted
    const splashScreen = document.getElementById('splash-screen')
    if (splashScreen) {
      splashScreen.style.opacity = '0'
      splashScreen.style.transition = 'opacity 0.5s ease-out'
      setTimeout(() => {
        splashScreen.style.display = 'none'
      }, 500)
    }
  }, [])

  const checkAuth = async () => {
    try {
      const apiKey = await window.electron.store.get('apiKey')
      if (!apiKey) {
        setAuthStatus({ loading: false, authenticated: false })
        return
      }
      
      const status = await window.electron.auth.getStatus()
      setAuthStatus({ loading: false, authenticated: status.authenticated })
      
      if (!status.authenticated) {
        await window.electron.store.set('apiKey', null)
      }
    } catch (error) {
      console.error('Auth check failed:', error)
      setAuthStatus({ loading: false, authenticated: false })
      await window.electron.store.set('apiKey', null)
    }
  }

  if (authStatus.loading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-gray-400">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-400 mx-auto mb-4"></div>
          <div>Loading...</div>
        </div>
      </div>
    )
  }

  if (!authStatus.authenticated) {
    return <AuthScreen />
  }

  return (
    <NetworkProvider>
      <ChatProvider>
        <div className="min-h-screen bg-gray-900 text-white flex flex-col">
          {/* Header */}
          <header className="fixed top-0 left-0 right-0 z-10 bg-gray-900 border-b border-gray-800">
            <MainLayout>
              <div className="flex items-center gap-4">
                
                <div className="h-6 border-r border-gray-700" />
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => setActiveView('chat')}
                    className={`flex items-center gap-2 px-3 py-1 rounded-full ${
                      activeView === 'chat' ? 'bg-blue-600' : 'bg-gray-800 hover:bg-gray-700'
                    }`}
                  >
                    <ChatBubbleLeftRightIcon className="w-4 h-4" />
                    <span>Chat</span>
                  </button>
                  <button
                    onClick={() => setActiveView('network')}
                    className={`flex items-center gap-2 px-3 py-1 rounded-full ${
                      activeView === 'network' ? 'bg-blue-600' : 'bg-gray-800 hover:bg-gray-700'
                    }`}
                  >
                    <ShareIcon className="w-4 h-4" />
                    <span>Network</span>
                  </button>
                </div>
                <StatusBar />
              </div>
            </MainLayout>
          </header>

          {/* Main Content */}
          <main className="flex-1 pt-[75px]">
            {activeView === 'chat' ? (
              <ChatView />
            ) : (
              <div className="mx-auto w-full h-full p-4 pb-4">
                <div className="space-y-4">
                  <div className="bg-gray-800 rounded-lg p-4">
                    <ModelList />
                  </div>
                  <div className="bg-gray-800 rounded-lg p-4">
                    <ActivityLog />
                  </div>
                </div>
              </div>
            )}
          </main>

          {/* Footer */}
          <footer className="fixed bottom-0 left-0 right-0 z-10 bg-gray-900 border-t border-gray-800">
            <NetworkStats />
          </footer>
        </div>
        <Toaster 
          position="bottom-right"
          toastOptions={{
            style: {
              background: '#1f2937',
              color: '#fff',
              borderRadius: '8px',
              border: '1px solid #374151'
            }
          }}
        />
      </ChatProvider>
    </NetworkProvider>
  )
}

export default App

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/ActivityLog.jsx ---
import React from 'react'
import { useNetwork } from '../contexts/NetworkContext'

export default function ActivityLog() {
  const { activity } = useNetwork()

  const getActivityIcon = (type) => {
    switch (type) {
      case 'completion_start':
        return '⏳'
      case 'completion_success':
        return '✅'
      case 'completion_error':
        return '❌'
      default:
        return '📝'
    }
  }

  return (
    <div className="flex flex-col">
      <h2 className="text-xl text-white mb-4">Activity Log</h2>
      
      <div className="flex-1 overflow-y-auto min-h-0 font-mono">
        {activity.length === 0 ? (
          <div className="text-gray-400 text-center py-8">
            <p>No activity yet</p>
            <p className="text-sm mt-2">Start sharing to see requests</p>
          </div>
        ) : (
          <div className="space-y-1">
            {activity.map((log, index) => (
              <div 
                key={index}
                className="bg-gray-800/50 hover:bg-gray-800 transition-colors rounded-md px-3 py-2 text-sm"
              >
                <div className="flex items-start gap-2">
                  <span className="text-gray-400 select-none">{getActivityIcon(log.type)}</span>
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <span className="text-green-400">{log.type}</span>
                      <span className="text-gray-500 text-xs">
                        {new Date(log.timestamp).toLocaleTimeString()}
                      </span>
                    </div>
                    <p className="text-gray-300 break-all">{log.message}</p>
                    {log.tokens && (
                      <p className="text-gray-500 text-xs mt-1">
                        Tokens: {log.tokens.total_tokens} (prompt: {log.tokens.prompt_tokens}, completion: {log.tokens.completion_tokens})
                      </p>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/ModelList.jsx ---
import React from 'react'
import { useNetwork } from '../contexts/NetworkContext'
import { ArrowPathIcon } from '@heroicons/react/24/solid'

export default function ModelList() {
  const { localModels, isDetecting, detectServices } = useNetwork()

  return (
    <div className="flex flex-col">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl text-white">Local Available Models</h2>
        <button
          onClick={detectServices}
          disabled={isDetecting}
          className="px-3 py-1 rounded-md bg-gray-700 hover:bg-gray-600 text-gray-300 flex items-center gap-2 text-sm"
        >
          <ArrowPathIcon 
            className={`w-4 h-4 ${isDetecting ? 'animate-spin' : ''}`} 
          />
          <span>Refresh</span>
        </button>
      </div>

      <div className="flex-1 overflow-y-auto min-h-0">
        {localModels.length === 0 ? (
          <div className="text-center py-8">
            <div className="text-4xl mb-4">⚠️</div>
            <p className="text-gray-400 mb-2">No Local LLM Services Detected</p>
            <p className="text-sm text-gray-500 mb-4">Install Ollama, LM Studio, EXO, or vLLM to share your models</p>
          </div>
        ) : (
          <div className="space-y-1">
            {localModels.map((model) => (
              <div 
                key={`${model.type}-${model.name}`}
                className="bg-gray-700/50 hover:bg-gray-700 transition-colors rounded-md p-3 flex justify-between items-center"
              >
                <div>
                  <h3 className="text-white font-mono text-sm">{model.name}</h3>
                  <p className="text-gray-400 text-xs">via {model.type}</p>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-2 h-2 rounded-full bg-green-500" />
                  <span className="text-gray-400 text-xs">Ready</span>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/NetworkStats.jsx ---
import React from 'react'
import { useNetwork } from '../contexts/NetworkContext'
import { ArrowUpIcon, ArrowDownIcon } from '@heroicons/react/24/solid'

export default function NetworkStats() {
  const { balance, tokenStats = { tokensPerMinute: 0, tokensPerSecond: 0 }, isConnected } = useNetwork()

  return (
    <div className="bg-gray-900 border-t border-gray-800 ">
      <div className="p-3">
        <div className="flex justify-between items-center">
          <div className="flex items-center gap-6">
            {isConnected && (
              <>
                <div className="flex items-center gap-2">
                  <ArrowUpIcon className="w-4 h-4 text-green-500" />
                  <span className="text-gray-400 text-sm">
                    {tokenStats.tokensPerMinute > 0 
                      ? `Processing: ${tokenStats.tokensPerMinute} tokens/min`
                      : 'Waiting for requests...'}
                  </span>
                </div>
                {tokenStats.tokensPerMinute > 0 && (
                  <div className="flex items-center gap-2">
                    <ArrowDownIcon className="w-4 h-4 text-blue-500" />
                    <span className="text-gray-400 text-sm">Rate: {tokenStats.tokensPerSecond} tokens/sec</span>
                  </div>
                )}
              </>
            )}
          </div>
          
          <div className="flex items-center gap-4">
            <div className="text-sm">
              <span className="text-gray-400">Balance: </span>
              <span className="text-white font-mono">{Number(balance).toFixed(6)} MULE</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/StatusBar.jsx ---
import React from 'react'
import { useNetwork } from '../contexts/NetworkContext'
import { Switch } from '@headlessui/react'

export default function StatusBar() {
  const { isConnected, connect, disconnect, isDetecting, models } = useNetwork()
  const hasModels = models?.length > 0 || false

  const toggleConnection = async () => {
    if (isConnected) {
      await disconnect()
    } else {
      await connect(models)
    }
  }

  return (
    <div className="flex items-center gap-3">
      <span className="text-gray-400 text-sm">Share</span>
      <Switch
        checked={isConnected}
        onChange={toggleConnection}
        disabled={isDetecting || (!hasModels && !isConnected)}
        title={!hasModels && !isConnected ? 'No models available to share' : ''}
        className={`${
          isConnected ? 'bg-green-600' : 'bg-gray-700'
        } relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed`}
      >
        <span
          className={`${
            isConnected ? 'translate-x-6' : 'translate-x-1'
          } inline-block h-4 w-4 transform rounded-full bg-white transition-transform`}
        />
      </Switch>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/auth/AuthScreen.jsx ---
import React, { useState } from 'react'
import toast from 'react-hot-toast'

export default function AuthScreen() {
  const [apiKey, setApiKey] = useState('')
  const [email, setEmail] = useState('')
  const [isRequestingKey, setIsRequestingKey] = useState(false)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState('')

  const handleSubmitApiKey = async (e) => {
    e.preventDefault()
    setIsLoading(true)
    setError('')
    
    if (!apiKey.trim()) {
      setError('Please enter an API key')
      setIsLoading(false)
      return
    }

    try {
      // First store the API key
      await window.electron.store.set('apiKey', apiKey)
      
      // Then validate it
      const isValid = await window.electron.auth.getStatus()
      
      if (!isValid.authenticated) {
        throw new Error('Invalid API key')
      }
      
      toast.success('Successfully connected!')
      window.location.reload()
    } catch (error) {
      const message = error.message || 'Failed to validate API key'
      toast.error(message)
      setError(message)
      // Clear invalid API key
      await window.electron.store.set('apiKey', null)
    } finally {
      setIsLoading(false)
    }
  }

  const handleRequestKey = async (e) => {
    e.preventDefault()
    setIsLoading(true)
    setError('')

    if (!email.trim()) {
      setError('Please enter your email')
      setIsLoading(false)
      return
    }

    try {
      await window.electron.auth.register(email)
      toast.success('API key sent! Please check your email')
      setIsRequestingKey('success')
    } catch (error) {
      const message = error.message || 'Failed to request API key'
      toast.error(message)
      setError(message)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="min-h-screen bg-gray-900 flex items-center justify-center p-4">
      <div className="w-full max-w-md space-y-8">
        <div className="text-center">
          <h1 className="text-2xl font-bold text-white">Welcome to LLMule</h1>
          <p className="mt-2 text-gray-400">Share your LLMs with the world</p>
        </div>

        {isRequestingKey === 'success' ? (
          <div className="text-center space-y-6">
            <div className="bg-gray-800/50 rounded-lg p-6 space-y-4">
              <div className="text-4xl">📧</div>
              <h2 className="text-xl font-semibold text-white">Check Your Email</h2>
              <div className="space-y-2 text-gray-400">
                <p>We've sent your API key to <span className="text-white">{email}</span></p>
                <p className="text-sm">Please check your inbox and spam folder. It should arrive within a few minutes.</p>
              </div>
            </div>
            <button
              onClick={() => setIsRequestingKey(false)}
              className="text-indigo-400 hover:text-indigo-300 text-sm"
            >
              ← Back to login
            </button>
          </div>
        ) : !isRequestingKey ? (
          <>
            <form onSubmit={handleSubmitApiKey} className="mt-8 space-y-6">
              <div>
                <label htmlFor="apiKey" className="block text-sm font-medium text-gray-400">
                  API Key
                </label>
                <input
                  type="text"
                  value={apiKey}
                  onChange={(e) => setApiKey(e.target.value)}
                  className={`mt-1 block w-full rounded-md bg-gray-800 border ${
                    error ? 'border-red-500' : 'border-gray-700'
                  } text-white px-3 py-2`}
                  placeholder="llm_..."
                  disabled={isLoading}
                />
                {error && <p className="mt-1 text-sm text-red-500">{error}</p>}
              </div>
              <button
                type="submit"
                disabled={isLoading}
                className="w-full py-2 px-4 rounded-md text-white bg-indigo-600 hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isLoading ? 'Connecting...' : 'Connect'}
              </button>
              <button
                type="button"
                onClick={() => setIsRequestingKey(true)}
                disabled={isLoading}
                className="w-full py-2 text-sm text-gray-400 hover:text-white disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Need an API key?
              </button>
            </form>
          </>
        ) : (
          <form onSubmit={handleRequestKey} className="mt-8 space-y-6">
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-400">
                Email
              </label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className={`mt-1 block w-full rounded-md bg-gray-800 border ${
                  error ? 'border-red-500' : 'border-gray-700'
                } text-white px-3 py-2`}
                placeholder="you@example.com"
                disabled={isLoading}
              />
              {error && <p className="mt-1 text-sm text-red-500">{error}</p>}
            </div>
            <button
              type="submit"
              disabled={isLoading}
              className="w-full py-2 px-4 rounded-md text-white bg-indigo-600 hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isLoading ? 'Requesting...' : 'Request API Key'}
            </button>
            <button
              type="button"
              onClick={() => setIsRequestingKey(false)}
              disabled={isLoading}
              className="w-full py-2 text-sm text-gray-400 hover:text-white disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Back to login
            </button>
          </form>
        )}
      </div>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/chat/ChatConfig.jsx ---
import React, { Fragment } from 'react';
import { Dialog, Transition } from '@headlessui/react';
import { XMarkIcon } from '@heroicons/react/24/outline';

export default function ChatConfig({ isOpen, onClose, config, onConfigChange }) {
  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-50" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel className="w-full max-w-md transform overflow-hidden rounded-lg bg-gray-800 p-6 shadow-xl transition-all">
                <div className="flex items-center justify-between mb-4">
                  <Dialog.Title className="text-lg font-medium text-white">
                    Chat Configuration
                  </Dialog.Title>
                  <button
                    onClick={onClose}
                    className="text-gray-400 hover:text-white"
                  >
                    <XMarkIcon className="w-5 h-5" />
                  </button>
                </div>

                <div className="space-y-4">
                  {/* System Prompt */}
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-2">
                      System Prompt
                    </label>
                    <textarea
                      value={config.systemPrompt}
                      onChange={(e) => onConfigChange({ ...config, systemPrompt: e.target.value })}
                      className="w-full bg-gray-700 text-white rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      rows={3}
                      placeholder="Enter a system prompt to set the behavior of the AI..."
                    />
                  </div>

                  {/* Temperature */}
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-2">
                      Temperature: {config.temperature}
                    </label>
                    <input
                      type="range"
                      min="0"
                      max="2"
                      step="0.1"
                      value={config.temperature}
                      onChange={(e) => onConfigChange({ ...config, temperature: parseFloat(e.target.value) })}
                      className="w-full"
                    />
                    <div className="flex justify-between text-xs text-gray-400">
                      <span>More Focused</span>
                      <span>More Creative</span>
                    </div>
                  </div>

                  {/* Max Tokens */}
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-2">
                      Max Tokens
                    </label>
                    <input
                      type="number"
                      value={config.maxTokens}
                      onChange={(e) => onConfigChange({ ...config, maxTokens: parseInt(e.target.value) })}
                      min="1"
                      max="4096"
                      className="w-full bg-gray-700 text-white rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                    <p className="mt-1 text-xs text-gray-400">
                      Maximum: 4096 tokens
                    </p>
                  </div>
                </div>

                <div className="mt-6 flex justify-end">
                  <button
                    onClick={onClose}
                    className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    Done
                  </button>
                </div>
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  );
} 

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/chat/ChatInput.jsx ---
import React, { useState, useRef, useEffect } from 'react';
import { PaperAirplaneIcon } from '@heroicons/react/24/solid';
import { ExclamationTriangleIcon } from '@heroicons/react/24/outline';
import { toast } from 'react-hot-toast';

export default function ChatInput({ 
  onSend, 
  disabled, 
  placeholder = "Type a message...",
  insufficientBalance = false,
  balanceInfo = null
}) {
  const [message, setMessage] = useState('');
  const [hasFocus, setHasFocus] = useState(false);
  const textareaRef = useRef(null);
  const messageRef = useRef(message);

  // Keep messageRef in sync with message state
  useEffect(() => {
    messageRef.current = message;
  }, [message]);

  // Preserve focus and message during re-renders
  useEffect(() => {
    if (hasFocus && textareaRef.current) {
      textareaRef.current.focus();
      // Restore cursor to end of text
      const length = messageRef.current.length;
      textareaRef.current.setSelectionRange(length, length);
    }
  }, [hasFocus, disabled]);

  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`;
    }
  }, [message]);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!message.trim() || disabled) return;
    
    if (insufficientBalance) {
      // Prevent sending if there's insufficient balance
      toast.error('Insufficient balance. Please share models or contact us.');
      return;
    }
    
    onSend(message.trim());
    setMessage('');
    
    // Reset textarea height
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
    }
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="bg-gray-800 p-4">
      <div className="max-w-3xl mx-auto">
        <div className={`flex items-end gap-2 bg-gray-700 rounded-xl p-2 ${insufficientBalance ? 'border border-red-500/50' : ''}`}>
          <div className="flex-1 min-w-0">
            <textarea
              ref={textareaRef}
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              onKeyDown={handleKeyDown}
              onFocus={() => setHasFocus(true)}
              onBlur={() => setHasFocus(false)}
              placeholder={insufficientBalance ? "Insufficient balance. Please share models or contact us." : placeholder}
              rows={1}
              disabled={disabled}
              className={`w-full bg-transparent text-white px-3 py-2 focus:outline-none resize-none transition-colors ${
                disabled ? 'opacity-50 cursor-not-allowed' : ''
              }`}
              style={{
                minHeight: '24px',
                maxHeight: '200px'
              }}
            />
          </div>
          <button
            type="submit"
            disabled={!message.trim() || disabled}
            className={`flex items-center justify-center rounded-lg p-2 h-[36px] w-[36px] flex-shrink-0 transition-colors ${
              message.trim() && !disabled
                ? insufficientBalance 
                  ? 'bg-red-600 hover:bg-red-700 text-white'
                  : 'bg-blue-600 hover:bg-blue-700 text-white'
                : 'text-gray-400'
            } disabled:opacity-50 disabled:cursor-not-allowed`}
          >
            <PaperAirplaneIcon className="w-5 h-5" />
          </button>
        </div>
        <div className="mt-2 text-xs text-gray-400 text-center">
          Press Enter to send, Shift + Enter for new line
        </div>
      </div>
    </form>
  );
} 

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/chat/ChatInterface.jsx ---
import React, { useEffect, useRef, useState } from 'react';
import { useChat } from '../../contexts/ChatContext';
import { useNetwork } from '../../contexts/NetworkContext';
import ChatMessage from './ChatMessage';
import ChatInput from './ChatInput';
import ChatConfig from './ChatConfig';
import { toast } from 'react-hot-toast';
import { ArrowPathIcon, PencilIcon, Cog6ToothIcon, EnvelopeIcon, ShareIcon } from '@heroicons/react/24/outline';
import ModelSelector from './ModelSelector';
import axios from 'axios';

export default function ChatInterface() {
  const { 
    currentConversation,
    sendMessage,
    isLoading,
    isSaving,
    availableModels,
    createNewConversation,
    changeConversationModel,
    deleteMessage,
    editMessage,
    updateConversationTitle,
    setCurrentConversation,
    setConversations,
    chatConfig,
    updateChatConfig
  } = useChat();
  
  const { isConnected, refreshModels, isDetecting } = useNetwork();
  const messagesEndRef = useRef(null);
  const [pendingMessage, setPendingMessage] = useState(null);
  const [isEditingTitle, setIsEditingTitle] = useState(false);
  const [editedTitle, setEditedTitle] = useState('');
  const [isConfigOpen, setIsConfigOpen] = useState(false);
  const [insufficientBalance, setInsufficientBalance] = useState(false);
  const [balanceInfo, setBalanceInfo] = useState(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [currentConversation?.messages]);

  useEffect(() => {
    if (currentConversation) {
      setEditedTitle(currentConversation.title);
    }
  }, [currentConversation?.id]);

  const handleSend = async (content) => {
    if (!availableModels.length) {
      toast.error('No models available');
      return;
    }
    
    // Reset balance state on new message
    setInsufficientBalance(false);
    setBalanceInfo(null);
    
    try {
      const modelId = currentConversation?.modelId || availableModels[0].id;
      let conversationId = currentConversation?.id;
      
      // Create user message
      const userMessage = {
        role: 'user',
        content,
        timestamp: new Date().toISOString()
      };

      // Update conversation immediately with user message and thinking state
      let updatedConversation;
      if (!currentConversation) {
        // Create new conversation if none exists
        updatedConversation = {
          id: crypto.randomUUID(),
          modelId,
          messages: [userMessage],
          title: content.slice(0, 30) + (content.length > 30 ? '...' : ''),
          isThinking: true,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
      } else {
        updatedConversation = {
          ...currentConversation,
          messages: [...currentConversation.messages, userMessage],
          isThinking: true,
          updatedAt: new Date().toISOString()
        };
      }

      setConversations(prev => [
        updatedConversation,
        ...prev.filter(c => c?.id !== updatedConversation.id)
      ]);
      setCurrentConversation(updatedConversation);
      
      // Prepare messages array with system prompt if present
      const messages = [];
      if (chatConfig.systemPrompt) {
        messages.push({
          role: 'system',
          content: chatConfig.systemPrompt
        });
      }
      
      // Add all previous messages plus the new one
      messages.push(...updatedConversation.messages);
      
      // Get API response with configuration
      const apiKey = await window.electron.store.get('apiKey');
      try {
        const response = await axios.post(
          `${window.electron.config.API_URL}/v1/chat/completions`,
          {
            model: modelId,
            messages: messages,
            temperature: chatConfig.temperature,
            max_tokens: chatConfig.maxTokens,
          },
          {
            headers: {
              'Authorization': `Bearer ${apiKey}`,
              'Accept': 'application/json'
            }
          }
        );

        // Add AI response and update UI
        const aiMessage = { 
          role: 'assistant',
          content: response.data.choices[0].message.content,
          timestamp: new Date().toISOString()
        };

        // Update conversation with AI response and remove thinking state
        const finalConversation = {
          ...updatedConversation,
          messages: [...updatedConversation.messages, aiMessage],
          isThinking: false,
          updatedAt: new Date().toISOString()
        };

        setConversations(prev => [
          finalConversation,
          ...prev.filter(c => c?.id !== updatedConversation.id)
        ]);
        setCurrentConversation(finalConversation);

      } catch (error) {
        console.error('Failed to send message:', error);
        
        // Check for insufficient balance error
        const isInsufficientBalance = 
          error.response?.status === 402 || 
          error.response?.data?.error?.code === 'insufficient_balance' ||
          error.response?.data?.originalError?.code === 'INSUFFICIENT_BALANCE';

        if (isInsufficientBalance) {
          // Get available balance from error message if available
          const errorMessage = error.response?.data?.originalError?.message || '';
          const balanceMatch = errorMessage.match(/Available: ([-\d.]+) MULE/);
          const availableBalance = balanceMatch ? balanceMatch[1] : null;

          // Set insufficient balance state
          setInsufficientBalance(true);
          setBalanceInfo({ availableBalance });

          // Add insufficient balance message to the conversation
          const insufficientBalanceMessage = {
            role: 'assistant',
            content: 'INSUFFICIENT_BALANCE',
            timestamp: new Date().toISOString(),
            metadata: {
              availableBalance,
              type: 'insufficient_balance'
            }
          };

          // Update conversation with the error message and remove thinking state
          const errorConversation = {
            ...updatedConversation,
            messages: [...updatedConversation.messages, insufficientBalanceMessage],
            isThinking: false,
            updatedAt: new Date().toISOString()
          };

          setConversations(prev => [
            errorConversation,
            ...prev.filter(c => c?.id !== updatedConversation.id)
          ]);
          setCurrentConversation(errorConversation);

        } else {
          toast.error('Failed to get response from the model');
          
          // Remove thinking state in case of error
          const errorConversation = {
            ...updatedConversation,
            isThinking: false
          };
          setConversations(prev => [
            errorConversation,
            ...prev.filter(c => c?.id !== updatedConversation.id)
          ]);
          setCurrentConversation(errorConversation);
        }
      }
    } catch (error) {
      console.error('Failed to prepare message:', error);
      toast.error('Failed to prepare message');
    }
  };

  const handleModelChange = (modelId) => {
    if (currentConversation) {
      changeConversationModel(currentConversation.id, modelId);
    } else {
      createNewConversation(modelId);
    }
  };

  const regenerateResponse = async (messageIndex) => {
    if (!availableModels.length) {
      toast.error('No models available');
      return;
    }
    
    const modelId = currentConversation?.modelId || availableModels[0].id;
    
    try {
      const messages = [...currentConversation.messages];
      
      // Find the previous user message before this assistant message
      let userMessageIndex = messageIndex - 1;
      while (userMessageIndex >= 0 && messages[userMessageIndex].role !== 'user') {
        userMessageIndex--;
      }
      
      if (userMessageIndex === -1) {
        toast.error('No user message found to regenerate response');
        return;
      }

      // Keep only messages up to the user message
      const updatedMessages = messages.slice(0, userMessageIndex + 1);
      
      // Update conversation state to show only up to user message
      const updatedConversation = {
        ...currentConversation,
        messages: updatedMessages,
        updatedAt: new Date().toISOString()
      };
      
      // Update the current conversation first
      setCurrentConversation(updatedConversation);

      // Set pending state
      setPendingMessage({ 
        role: 'assistant', 
        content: '',
        isLoading: true,
        timestamp: new Date().toISOString()
      });

      // Get API response
      const apiKey = await window.electron.store.get('apiKey');
      const response = await axios.post(
        `${window.electron.config.API_URL}/v1/chat/completions`,
        {
          model: modelId,
          messages: updatedMessages,
          temperature: 0.7,
          max_tokens: 4096,
        },
        {
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Accept': 'application/json'
          }
        }
      );

      // Create assistant message
      const assistantMessage = { 
        role: 'assistant',
        content: response.data.choices[0].message.content,
        timestamp: new Date().toISOString()
      };
      
      // Update conversation with new response
      const finalConversation = {
        ...updatedConversation,
        messages: [...updatedMessages, assistantMessage],
        updatedAt: new Date().toISOString()
      };
      
      setCurrentConversation(finalConversation);

    } catch (error) {
      console.error('Failed to regenerate response:', error);
      toast.error('Failed to regenerate response');
    } finally {
      setPendingMessage(null);
    }
  };

  const handleTitleEdit = () => {
    if (isEditingTitle && editedTitle.trim()) {
      updateConversationTitle(currentConversation.id, editedTitle.trim());
      setIsEditingTitle(false);
    } else {
      setIsEditingTitle(true);
    }
  };

  const handleTitleKeyDown = (e) => {
    if (e.key === 'Enter') {
      handleTitleEdit();
    } else if (e.key === 'Escape') {
      setIsEditingTitle(false);
      setEditedTitle(currentConversation.title);
    }
  };

  const InsufficientBalanceMessage = ({ availableBalance }) => (
    <div className="container max-w-4xl mx-auto px-4 py-6">
      <div className="flex gap-6">
        <div className="w-8 h-8 rounded-full flex items-center justify-center shrink-0 bg-gray-700">
          🤖
        </div>
        <div className="flex-1">
          <div className="prose prose-invert">
            <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-4">
              <h4 className="text-red-500 m-0 mb-2">Insufficient Balance</h4>
              <p className="text-sm text-gray-300 m-0">
                Please contact us as we're in beta.
              </p>
              <div className="flex gap-2 mt-3">
                <button
                  onClick={() => window.electron.shell.openExternal('mailto:llmule@cm64.studio')}
                  className="flex items-center gap-1 px-3 py-1.5 bg-gray-700 hover:bg-gray-600 rounded text-sm text-white"
                >
                  Contact Us
                </button>
                <button
                  onClick={() => handleSend(currentConversation.messages[currentConversation.messages.length - 2].content)}
                  className="flex items-center gap-1 px-3 py-1.5 bg-blue-600 hover:bg-blue-500 rounded text-sm text-white"
                >
                  Try Again
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );

  if (isDetecting) {
    return (
      <div className="flex-1 flex items-center justify-center p-4">
        <div className="text-center text-gray-400 max-w-md">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"></div>
          <h3 className="text-xl font-semibold mb-2">Detecting Models</h3>
          <p className="text-sm">Please wait while we detect available models...</p>
        </div>
      </div>
    );
  }

  if (!availableModels.length) {
    return (
      <div className="flex-1 flex items-center justify-center p-4">
        <div className="text-center text-gray-400 max-w-md">
          <div className="text-4xl mb-4">🤖</div>
          <h3 className="text-xl font-semibold mb-2">No Models Available</h3>
          <p className="text-sm mb-4">
            Please wait while we fetch available models.
            If this persists, try clicking the refresh button below.
          </p>
          <button
            onClick={refreshModels}
            disabled={isDetecting}
            className="inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <ArrowPathIcon className={`w-5 h-5 ${isDetecting ? 'animate-spin' : ''}`} />
            {isDetecting ? 'Detecting Models...' : 'Refresh Models'}
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex-1 flex flex-col h-full">
      {/* Header with model selector */}
      <div className="bg-gray-800/50 border-b border-gray-700 sticky top-0 z-10">
        <div className="container max-w-4xl mx-auto px-4 py-2">
          <div className="flex items-center gap-4">
            <div className="flex-1 flex items-center gap-2">
              <ModelSelector
                models={availableModels}
                selectedModelId={currentConversation?.modelId || availableModels[0].id}
                onModelChange={handleModelChange}
                disabled={isLoading}
              />
              <button
                onClick={() => setIsConfigOpen(true)}
                className="p-2 text-gray-400 hover:text-white rounded-lg hover:bg-gray-700 transition-colors"
                title="Chat Configuration"
              >
                <Cog6ToothIcon className="w-4 h-4" />
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto">
        <div className="container max-w-4xl mx-auto">
          {!currentConversation?.messages?.length ? (
            <div className="h-[calc(100vh-200px)] flex items-center justify-center">
              <div className="text-center text-gray-400">
                <div className="text-4xl mb-4">💭</div>
                <h3 className="text-xl font-semibold mb-2">Start a Conversation</h3>
                <p className="text-sm">
                  Type a message to begin your conversation with {availableModels.find(m => m.id === (currentConversation?.modelId || availableModels[0].id))?.id}
                </p>
              </div>
            </div>
          ) : (
            <div className="divide-y divide-gray-700/50">
              {currentConversation.messages.map((message, index) => (
                message.content === 'INSUFFICIENT_BALANCE' ? (
                  <InsufficientBalanceMessage
                    key={`${message.timestamp}-${index}`}
                    availableBalance={message.metadata?.availableBalance}
                  />
                ) : (
                  <ChatMessage 
                    key={`${message.timestamp}-${index}`} 
                    message={message}
                    onDelete={() => deleteMessage(currentConversation.id, index)}
                    onEdit={(newContent, shouldRegenerate) => editMessage(currentConversation.id, index, newContent, shouldRegenerate)}
                    onRegenerate={(messageIndex) => regenerateResponse(messageIndex)}
                    isLoading={isLoading}
                    messageIndex={index}
                    totalMessages={currentConversation.messages.length}
                  />
                )
              ))}
              {currentConversation?.isThinking && (
                <div className="container max-w-4xl mx-auto px-4 py-6">
                  <div className="flex gap-6">
                    <div className="w-8 h-8 rounded-full flex items-center justify-center shrink-0 bg-gray-700">
                      🤖
                    </div>
                    <div className="flex items-center gap-2 text-gray-400">
                      <div className="flex gap-2">
                        <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                        <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                        <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                      </div>
                      <span className="text-sm">Thinking...</span>
                    </div>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      {/* Chat Input */}
      <div className="border-t border-gray-700">
        <div className="container mx-auto">
          <ChatInput
            onSend={handleSend}
            disabled={isLoading && !insufficientBalance}
            pendingMessage={pendingMessage}
            setPendingMessage={setPendingMessage}
            insufficientBalance={insufficientBalance}
            balanceInfo={balanceInfo}
          />
        </div>
      </div>

      <ChatConfig
        isOpen={isConfigOpen}
        onClose={() => setIsConfigOpen(false)}
        config={chatConfig}
        onConfigChange={updateChatConfig}
      />
    </div>
  );
} 

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/chat/ChatMessage.jsx ---
import React, { useState } from 'react';
import ReactMarkdown from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import remarkGfm from 'remark-gfm';
import { PencilIcon, TrashIcon, ClipboardIcon, CheckIcon, ArrowPathIcon, Square2StackIcon } from '@heroicons/react/24/outline';
import { useChat } from '../../contexts/ChatContext';
import { toast } from 'react-hot-toast';

export default function ChatMessage({ message, onDelete, onEdit, onRegenerate, isLoading, messageIndex, totalMessages }) {
  const [isEditing, setIsEditing] = useState(false);
  const [editedContent, setEditedContent] = useState(message.content);
  const [isCopied, setIsCopied] = useState(false);
  const { createNewConversation, currentConversation } = useChat();

  // Show loading indicator only for the last message when there's a pending response
  const showLoading = currentConversation?.pendingResponse && 
                     messageIndex === (currentConversation.messages.length - 1) &&
                     message.role === 'user';

  const handleFork = async () => {
    try {
      // Get messages up to current point
      const messagesUpToPoint = currentConversation.messages.slice(0, messageIndex + 1);
      
      // Create new conversation with same model and messages up to this point
      await createNewConversation(currentConversation.modelId, messagesUpToPoint);
      
      toast.success('Created new conversation from this point');
    } catch (error) {
      console.error('Failed to fork conversation:', error);
      toast.error('Failed to create fork');
    }
  };

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(message.content);
      setIsCopied(true);
      setTimeout(() => setIsCopied(false), 2000);
      toast.success('Copied to clipboard');
    } catch (err) {
      toast.error('Failed to copy to clipboard');
    }
  };

  const handleEdit = () => {
    if (isEditing) {
      if (editedContent.trim() !== message.content) {
        onEdit(editedContent, true); // true indica regenerar respuestas
      }
      setIsEditing(false);
    } else {
      setIsEditing(true);
    }
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
      handleEdit();
    } else if (e.key === 'Escape') {
      setIsEditing(false);
      setEditedContent(message.content);
    }
  };

  const isLastUserMessage = message.role === 'user' && messageIndex < totalMessages - 1;

  return (
    <div className={`${message.role === 'assistant' ? 'bg-gray-800/50' : ''}`}>
      <div className="container max-w-4xl mx-auto px-4 py-6">
        <div className="flex gap-6">
          <div className="w-8 h-8 rounded-full flex items-center justify-center shrink-0 bg-gray-700">
            {message.role === 'assistant' ? '🤖' : '👤'}
          </div>
          <div className="flex-1 min-w-0 overflow-hidden">
            <div className="flex items-start justify-between gap-4">
              <div className="flex-1 min-w-0 overflow-auto prose prose-invert prose-pre:my-0">
                {isEditing ? (
                  <textarea
                    value={editedContent}
                    onChange={(e) => setEditedContent(e.target.value)}
                    onKeyDown={handleKeyDown}
                    className="w-full bg-gray-700 text-white rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    rows={editedContent.split('\n').length}
                    autoFocus
                  />
                ) : (
                  <ReactMarkdown
                    remarkPlugins={[remarkGfm]}
                    components={{
                      code({ node, inline, className, children, ...props }) {
                        const match = /language-(\w+)/.exec(className || '');
                        return !inline && match ? (
                          <div className="relative group not-prose">
                            <div className="absolute right-2 top-2 opacity-0 group-hover:opacity-100 transition-opacity">
                              <button
                                onClick={() => {
                                  navigator.clipboard.writeText(String(children));
                                  toast.success('Code copied to clipboard');
                                }}
                                className="p-1 bg-gray-700 rounded hover:bg-gray-600"
                                title="Copy code"
                              >
                                <ClipboardIcon className="w-4 h-4" />
                              </button>
                            </div>
                            <div className="overflow-x-auto bg-gray-900 rounded-lg">
                              <SyntaxHighlighter
                                style={oneDark}
                                language={match[1]}
                                PreTag="div"
                                {...props}
                                customStyle={{
                                  margin: 0,
                                  borderRadius: '0.5rem',
                                  padding: '1rem',
                                  background: 'transparent'
                                }}
                              >
                                {String(children).replace(/\n$/, '')}
                              </SyntaxHighlighter>
                            </div>
                          </div>
                        ) : (
                          <code className={`${className} bg-gray-800 px-1.5 py-0.5 rounded`} {...props}>
                            {children}
                          </code>
                        );
                      },
                    }}
                  >
                    {message.content}
                  </ReactMarkdown>
                )}
              </div>
              <div className="flex items-center gap-1 shrink-0">
                {!isLoading && (
                  <>
                    {message.role === 'user' ? (
                      <>
                        <button
                          onClick={handleEdit}
                          className="p-1.5 text-gray-400 hover:text-white rounded-lg hover:bg-gray-700"
                          title={isEditing ? "Save (Cmd/Ctrl + Enter)" : "Edit"}
                        >
                          <PencilIcon className="w-4 h-4" />
                        </button>
                        <button
                          onClick={() => onDelete()}
                          className="p-1.5 text-gray-400 hover:text-red-500 rounded-lg hover:bg-gray-700"
                          title="Delete"
                        >
                          <TrashIcon className="w-4 h-4" />
                        </button>
                      </>
                    ) : (
                      <>
                        <button
                          onClick={() => onRegenerate(messageIndex)}
                          className="p-1.5 text-gray-400 hover:text-white rounded-lg hover:bg-gray-700"
                          title="Regenerate response"
                        >
                          <ArrowPathIcon className="w-4 h-4" />
                        </button>
                        <button
                          onClick={handleFork}
                          className="p-1.5 text-gray-400 hover:text-white rounded-lg hover:bg-gray-700"
                          title="Fork conversation from here"
                        >
                          <Square2StackIcon className="w-4 h-4" />
                        </button>
                        <button
                          onClick={() => onDelete()}
                          className="p-1.5 text-gray-400 hover:text-red-500 rounded-lg hover:bg-gray-700"
                          title="Delete message"
                        >
                          <TrashIcon className="w-4 h-4" />
                        </button>
                      </>
                    )}
                    <button
                      onClick={handleCopy}
                      className="p-1.5 text-gray-400 hover:text-white rounded-lg hover:bg-gray-700"
                      title="Copy to clipboard"
                    >
                      {isCopied ? (
                        <CheckIcon className="w-4 h-4 text-green-500" />
                      ) : (
                        <ClipboardIcon className="w-4 h-4" />
                      )}
                    </button>
                  </>
                )}
              </div>
            </div>
            <div className="mt-2 flex items-center gap-2 text-xs text-gray-500">
              {message.timestamp && (
                <span>{new Date(message.timestamp).toLocaleTimeString()}</span>
              )}
              {message.edited && (
                <span className="text-gray-600">(edited)</span>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
} 

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/chat/ChatSidebar.jsx ---
import React, { useState } from 'react';
import { useChat } from '../../contexts/ChatContext';
import { useNetwork } from '../../contexts/NetworkContext';
import { PlusIcon, TrashIcon, PencilIcon } from '@heroicons/react/24/outline';
import { toast } from 'react-hot-toast';

export default function ChatSidebar() {
  const {
    conversations,
    currentConversation,
    setCurrentConversation,
    availableModels,
    createNewConversation,
    deleteConversation,
    updateConversationTitle
  } = useChat();

  const { isConnected } = useNetwork();
  const [editingTitleId, setEditingTitleId] = useState(null);
  const [editedTitle, setEditedTitle] = useState('');

  const handleNewChat = async () => {
    if (!availableModels.length) {
      toast.error('No models available. Please wait for models to be detected.');
      return;
    }

    try {
      console.log('Creating new chat with model:', availableModels[0].id);
      const newConversation = await createNewConversation(availableModels[0].id);
      console.log('New conversation created:', newConversation);
      
      // Wait for state to update
      await new Promise(resolve => setTimeout(resolve, 100));
      
      if (newConversation?.id) {
        setCurrentConversation(newConversation);
      } else {
        throw new Error('Failed to create conversation');
      }
    } catch (error) {
      console.error('Failed to create new conversation:', error);
      toast.error('Failed to create new conversation');
    }
  };

  const handleEditTitle = (conversation) => {
    setEditingTitleId(conversation.id);
    setEditedTitle(conversation.title);
  };

  const handleTitleSave = (conversationId) => {
    if (editedTitle.trim()) {
      updateConversationTitle(conversationId, editedTitle.trim());
    }
    setEditingTitleId(null);
    setEditedTitle('');
  };

  const handleTitleKeyDown = (e, conversationId) => {
    if (e.key === 'Enter') {
      handleTitleSave(conversationId);
    } else if (e.key === 'Escape') {
      setEditingTitleId(null);
      setEditedTitle('');
    }
  };

  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString(undefined, {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <div className="w-80 bg-gray-800 border-r border-gray-700 flex flex-col h-full">
      {/* Header with Title and New Chat Button */}
      <div className="p-4 border-b border-gray-700">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <span className="text-xl">💬</span>
            <h2 className="text-xl font-semibold">Chats</h2>
          </div>
          <button
            onClick={handleNewChat}
            disabled={availableModels.length === 0}
            className="flex items-center gap-1.5 bg-gray-700 hover:bg-gray-600 text-white rounded-lg py-1.5 px-3 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
          >
            <PlusIcon className="w-4 h-4" />
            <span>New Chat</span>
            <span className="text-gray-400 text-xs">(⌘N)</span>
          </button>
        </div>
      </div>

      {/* Conversations List */}
      <div className="flex-1 overflow-y-auto">
        {conversations.map((conversation) => (
          <div
            key={conversation.id}
            onClick={() => setCurrentConversation(conversation)}
            className={`p-4 border-b border-gray-700 cursor-pointer hover:bg-gray-700 transition-colors ${
              currentConversation?.id === conversation.id ? 'bg-gray-700' : ''
            }`}
          >
            <div className="flex justify-between items-start gap-2">
              <div className="flex-1 min-w-0">
                {editingTitleId === conversation.id ? (
                  <input
                    type="text"
                    value={editedTitle}
                    onChange={(e) => setEditedTitle(e.target.value)}
                    onKeyDown={(e) => handleTitleKeyDown(e, conversation.id)}
                    onBlur={() => handleTitleSave(conversation.id)}
                    className="w-full bg-gray-600 text-white rounded px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Conversation title..."
                    autoFocus
                    onClick={(e) => e.stopPropagation()}
                  />
                ) : (
                  <div className="group">
                    <div className="flex items-center gap-2">
                      <h3 className="text-sm font-medium text-gray-200 truncate group-hover:text-white">
                        {conversation.title || 'New Conversation'}
                      </h3>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          handleEditTitle(conversation);
                        }}
                        className="p-1 -m-1 text-gray-400 hover:text-white opacity-0 group-hover:opacity-100 transition-opacity"
                        title="Edit title"
                      >
                        <PencilIcon className="w-3 h-3" />
                      </button>
                    </div>
                    <div className="flex items-center gap-2 mt-1">
                      <div className="flex-shrink-0 w-2 h-2 rounded-full bg-gradient-to-br from-blue-400 to-blue-600" />
                      <p className="text-xs text-gray-400">
                        {conversation.modelId}
                      </p>
                    </div>
                    <p className="text-xs text-gray-500 mt-1">
                      {formatDate(conversation.createdAt)}
                    </p>
                  </div>
                )}
              </div>
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  deleteConversation(conversation.id);
                }}
                className="text-gray-400 hover:text-red-500 transition-colors p-1"
                title="Delete conversation"
              >
                <TrashIcon className="w-4 h-4" />
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
} 

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/chat/ChatView.jsx ---
import React from 'react';
import ChatSidebar from './ChatSidebar';
import ChatInterface from './ChatInterface';

export default function ChatView() {
  return (
    <div className="flex-1 flex h-[calc(100vh-120px)]">
      <ChatSidebar />
      <div className="flex-1 flex flex-col bg-gray-900">
        <ChatInterface />
      </div>
    </div>
  );
} 

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/chat/ModelSelector.jsx ---
import React, { useState, useRef, useEffect } from 'react';
import { ChevronUpDownIcon, CheckIcon, ArrowPathIcon } from '@heroicons/react/24/outline';
import { useNetwork } from '../../contexts/NetworkContext';

export default function ModelSelector({ models, selectedModelId, onModelChange, disabled }) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);
  const { refreshModels, isDetecting } = useNetwork();

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const selectedModel = models.find(m => m.id === selectedModelId);

  return (
    <div className="flex items-center gap-2 flex-1 max-w-2xl">
      <div className="relative flex-1" ref={dropdownRef}>
        <button
          onClick={() => !disabled && setIsOpen(!isOpen)}
          disabled={disabled}
          className={`w-full flex items-center justify-between gap-2 bg-gray-700/50 hover:bg-gray-700 text-white rounded-lg pl-3 pr-2 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors ${
            isOpen ? 'ring-2 ring-blue-500' : ''
          }`}
        >
          <div className="flex items-center gap-2 min-w-0 flex-1">
            <div className="flex-shrink-0 w-3 h-3 rounded-full bg-gradient-to-br from-blue-400 to-blue-600" />
            <span className="truncate flex-1 text-left">{selectedModel?.id || 'Select a model'}</span>
            {selectedModel?.type === 'local' && (
              <span className="flex-shrink-0 px-1.5 py-0.5 text-xs bg-gray-600/50 text-gray-300 rounded">Local</span>
            )}
          </div>
          <ChevronUpDownIcon className="w-4 h-4 text-gray-400 flex-shrink-0" />
        </button>

        {isOpen && (
          <div className="absolute z-10 w-full mt-1 bg-gray-800 border border-gray-700 rounded-lg shadow-lg overflow-hidden">
            <div className="max-h-60 overflow-y-auto">
              {models.map((model) => (
                <button
                  key={model.id}
                  onClick={() => {
                    onModelChange(model.id);
                    setIsOpen(false);
                  }}
                  className={`w-full flex items-center gap-2 px-3 py-2 text-sm hover:bg-gray-700 transition-colors ${
                    model.id === selectedModelId ? 'bg-gray-700/50' : ''
                  }`}
                >
                  <div className="flex-shrink-0 w-3 h-3 rounded-full bg-gradient-to-br from-blue-400 to-blue-600" />
                  <span className="flex-1 truncate text-left">{model.id}</span>
                  {model.type === 'local' && (
                    <span className="flex-shrink-0 px-1.5 py-0.5 text-xs bg-gray-600/50 text-gray-300 rounded">Local</span>
                  )}
                  {model.id === selectedModelId && (
                    <CheckIcon className="w-4 h-4 text-blue-500 flex-shrink-0" />
                  )}
                </button>
              ))}
            </div>
          </div>
        )}
      </div>
      <button
        onClick={refreshModels}
        disabled={isDetecting || disabled}
        className="p-2 text-gray-400 hover:text-white rounded-lg hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex-shrink-0"
        title="Refresh models"
      >
        <ArrowPathIcon className={`w-4 h-4 ${isDetecting ? 'animate-spin' : ''}`} />
      </button>
    </div>
  );
} 

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/layouts/MainLayout.jsx ---
import React, { useState, useEffect, Fragment } from 'react'
import { useNetwork } from '../../contexts/NetworkContext'
import { Menu, Transition } from '@headlessui/react'
import { ChevronDownIcon, ArrowRightOnRectangleIcon } from '@heroicons/react/24/solid'

export default function MainLayout({ children }) {
  const { isConnected, tokenStats } = useNetwork()
  const [userEmail, setUserEmail] = useState('')

  useEffect(() => {
    const getUserInfo = async () => {
      try {
        const status = await window.electron.auth.getStatus()
        if (status.authenticated && status.user) {
          setUserEmail(status.user.email)
        }
      } catch (error) {
        console.error('Failed to get user info:', error)
      }
    }
    getUserInfo()
  }, [])

  const handleLogout = async () => {
    await window.electron.store.set('apiKey', null)
    window.location.reload()
  }

  return (
    <div className="p-4 flex items-center">
      <div className="flex-1 flex items-center gap-4">
        <h1 className="text-xl font-mono">⚡ LLMule</h1>
        
        {/* <div className="flex items-center gap-2 px-3 py-1 rounded-full bg-gray-800">
          <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
          <span className="text-gray-400 text-sm">
            {isConnected ? 'Connected to Network' : 'Disconnected'}
          </span>
        </div> */}
      </div>

      <div className="flex items-center gap-4">
        <Menu as="div" className="relative">
          <Menu.Button className="flex items-center gap-2 px-3 py-1 rounded-full bg-gray-800 hover:bg-gray-700 transition-colors">
            <span className="text-gray-300 text-sm">{userEmail}</span>
            <ChevronDownIcon className="w-4 h-4 text-gray-400" />
          </Menu.Button>
          
          <Transition
            as={Fragment}
            enter="transition ease-out duration-100"
            enterFrom="transform opacity-0 scale-95"
            enterTo="transform opacity-100 scale-100"
            leave="transition ease-in duration-75"
            leaveFrom="transform opacity-100 scale-100"
            leaveTo="transform opacity-0 scale-95"
          >
            <Menu.Items className="absolute right-0 mt-2 w-48 rounded-md bg-gray-800 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none">
              <Menu.Item>
                {({ active }) => (
                  <button
                    onClick={handleLogout}
                    className={`${
                      active ? 'bg-gray-700' : ''
                    } group flex w-full items-center px-4 py-2 text-sm text-gray-300`}
                  >
                    <ArrowRightOnRectangleIcon className="mr-3 h-5 w-5 text-gray-400" />
                    Logout
                  </button>
                )}
              </Menu.Item>
            </Menu.Items>
          </Transition>
        </Menu>

        <div className="flex justify-end">
          {children}
        </div>
      </div>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/contexts/ChatContext.jsx ---
import React, { createContext, useContext, useState, useEffect } from 'react';
import axios from 'axios';
import { useNetwork } from './NetworkContext';
import { toast } from 'react-hot-toast';
import { v4 as uuidv4 } from 'uuid';

const ChatContext = createContext();
const STORAGE_KEY = 'llmule_conversations';
const CONFIG_STORAGE_KEY = 'llmule_chat_config';

const DEFAULT_CONFIG = {
  systemPrompt: '',
  temperature: 0.7,
  maxTokens: 4096
};

export function ChatProvider({ children }) {
  const [conversations, setConversations] = useState([]);
  const [currentConversation, setCurrentConversation] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [chatConfig, setChatConfig] = useState(DEFAULT_CONFIG);
  const { networkModels } = useNetwork();

  // Load chat configuration from localStorage
  useEffect(() => {
    try {
      const storedConfig = localStorage.getItem(CONFIG_STORAGE_KEY);
      if (storedConfig) {
        setChatConfig(JSON.parse(storedConfig));
      }
    } catch (error) {
      console.error('Failed to load chat configuration:', error);
    }
  }, []);

  // Save chat configuration to localStorage
  const updateChatConfig = (newConfig) => {
    setChatConfig(newConfig);
    try {
      localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(newConfig));
    } catch (error) {
      console.error('Failed to save chat configuration:', error);
    }
  };

  // Load conversations from local storage on mount
  useEffect(() => {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        // Validate stored data
        const validConversations = parsed.filter(conv => 
          conv && conv.id && conv.modelId && Array.isArray(conv.messages)
        );
        setConversations(validConversations);
        // Set the most recent conversation as current if exists
        if (validConversations.length > 0) {
          setCurrentConversation(validConversations[0]);
        }
      }
    } catch (error) {
      console.error('Failed to load conversations:', error);
      toast.error('Failed to load previous conversations');
    }
  }, []);

  // Save conversations to local storage with debounce
  useEffect(() => {
    if (conversations.length === 0) return;
    
    const saveConversations = async () => {
      setIsSaving(true);
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations));
      } catch (error) {
        console.error('Failed to save conversations:', error);
        toast.error('Failed to save conversation changes');
      } finally {
        setIsSaving(false);
      }
    };

    const timeoutId = setTimeout(saveConversations, 500);
    return () => clearTimeout(timeoutId);
  }, [conversations]);

  const createNewConversation = async (modelId, initialMessages = []) => {
    const newConversation = {
      id: crypto.randomUUID(),
      modelId,
      messages: initialMessages,
      title: initialMessages.length > 0 ? 'Fork: ' + initialMessages[0].content.slice(0, 30) + '...' : 'New Conversation',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    try {
      // Update state with new conversation at the beginning of the list
      setConversations(prev => [newConversation, ...prev]);
      setCurrentConversation(newConversation);
      return newConversation;
    } catch (error) {
      console.error('Failed to create new conversation:', error);
      throw error;
    }
  };

  const updateConversation = (conversationId, updates) => {
    setConversations(prev => prev.map(conv => 
      conv.id === conversationId 
        ? { ...conv, ...updates, updatedAt: new Date().toISOString() }
        : conv
    ));
  };

  const updateConversationTitle = (conversationId, newTitle) => {
    const conversation = conversations.find(c => c.id === conversationId);
    if (!conversation) return;

    const updatedConversation = {
      ...conversation,
      title: newTitle,
      updatedAt: new Date().toISOString()
    };

    setConversations(prev => [
      updatedConversation,
      ...prev.filter(c => c.id !== conversationId)
    ]);
    setCurrentConversation(updatedConversation);
  };

  const sendMessage = async (content, modelId, conversationId) => {
    if (!networkModels.length) {
      toast.error('No models available');
      return;
    }

    try {
      // 1. Create user message
      const userMessage = { 
        role: 'user', 
        content, 
        timestamp: new Date().toISOString() 
      };

      // 2. Get or create conversation
      let conversation;
      if (!conversationId) {
        conversation = {
          id: crypto.randomUUID(),
          modelId,
          messages: [],
          title: content.slice(0, 30) + (content.length > 30 ? '...' : ''),
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
      } else {
        conversation = conversations.find(c => c.id === conversationId);
        if (!conversation) throw new Error('Conversation not found');
        conversation = { ...conversation };
      }

      // 3. Add user message and update UI
      conversation.messages = [...conversation.messages, userMessage];
      conversation.isThinking = true;
      
      setConversations(prev => [
        conversation,
        ...prev.filter(c => c.id !== conversation.id)
      ]);
      setCurrentConversation(conversation);

      // 4. Get API response with current configuration
      const apiKey = await window.electron.store.get('apiKey');
      const response = await axios.post(
        `${window.electron.config.API_URL}/v1/chat/completions`,
        {
          model: modelId,
          messages: conversation.messages,
          temperature: chatConfig.temperature,
          max_tokens: chatConfig.maxTokens,
        },
        {
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Accept': 'application/json'
          }
        }
      );

      // 5. Add AI response and update UI
      const aiMessage = { 
        role: 'assistant',
        content: response.data.choices[0].message.content,
        timestamp: new Date().toISOString()
      };

      conversation.messages = [...conversation.messages, aiMessage];
      conversation.isThinking = false;
      conversation.updatedAt = new Date().toISOString();

      setConversations(prev => [
        conversation,
        ...prev.filter(c => c.id !== conversation.id)
      ]);
      setCurrentConversation(conversation);

    } catch (error) {
      console.error('Failed to send message:', error);
      toast.error('Failed to get response from the model');
      
      // 6. Handle error by adding error message
      if (conversationId) {
        const conversation = conversations.find(c => c.id === conversationId);
        if (conversation) {
          const errorMessage = { 
            role: 'assistant', 
            content: 'Sorry, I encountered an error processing your request. Please try again.',
            timestamp: new Date().toISOString(),
            isError: true
          };
          
          const updatedConversation = {
            ...conversation,
            messages: [...conversation.messages, errorMessage],
            isThinking: false,
            updatedAt: new Date().toISOString()
          };
          
          setConversations(prev => [
            updatedConversation,
            ...prev.filter(c => c.id !== conversationId)
          ]);
          setCurrentConversation(updatedConversation);
        }
      }
    }
  };

  const deleteConversation = (conversationId) => {
    setConversations(prev => {
      const newConversations = prev.filter(c => c.id !== conversationId);
      // If we're deleting the current conversation, switch to the most recent one
      if (currentConversation?.id === conversationId) {
        setCurrentConversation(newConversations[0] || null);
      }
      return newConversations;
    });
  };

  const changeConversationModel = (conversationId, newModelId) => {
    if (!networkModels.find(m => m.id === newModelId)) {
      toast.error('Invalid model selected');
      return;
    }

    // Update conversation with new model
    const updatedConversation = {
      ...conversations.find(c => c.id === conversationId),
      modelId: newModelId,
      updatedAt: new Date().toISOString()
    };

    // Move conversation to top and update it
    setConversations(prev => [
      updatedConversation,
      ...prev.filter(c => c.id !== conversationId)
    ]);

    // Update current conversation
    setCurrentConversation(updatedConversation);

    // Show feedback
    toast.success(`Switched to model: ${newModelId}`);
  };

  const deleteMessage = (conversationId, messageIndex) => {
    const conversation = conversations.find(c => c.id === conversationId);
    if (!conversation) return;

    const updatedMessages = [...conversation.messages];
    updatedMessages.splice(messageIndex, 1);

    const updatedConversation = {
      ...conversation,
      messages: updatedMessages,
      updatedAt: new Date().toISOString()
    };

    setConversations(prev => [
      updatedConversation,
      ...prev.filter(c => c.id !== conversationId)
    ]);
    setCurrentConversation(updatedConversation);
  };

  const editMessage = (conversationId, messageIndex, newContent, shouldRegenerate = false) => {
    const conversation = conversations.find(c => c.id === conversationId);
    if (!conversation) return;

    let updatedMessages = [...conversation.messages];
    updatedMessages[messageIndex] = {
      ...updatedMessages[messageIndex],
      content: newContent,
      edited: true,
      editedAt: new Date().toISOString()
    };

    // Si shouldRegenerate es true, eliminar mensajes posteriores
    if (shouldRegenerate) {
      updatedMessages = updatedMessages.slice(0, messageIndex + 1);
    }

    const updatedConversation = {
      ...conversation,
      messages: updatedMessages,
      updatedAt: new Date().toISOString()
    };

    setConversations(prev => [
      updatedConversation,
      ...prev.filter(c => c.id !== conversationId)
    ]);
    setCurrentConversation(updatedConversation);

    // Si shouldRegenerate es true, regenerar la respuesta
    if (shouldRegenerate) {
      sendMessage(newContent, conversation.modelId, conversationId);
    }
  };

  const regenerateResponse = async (conversationId, messageIndex) => {
    const conversation = conversations.find(c => c.id === conversationId);
    if (!conversation) return;

    // Eliminar todos los mensajes después del índice del mensaje del usuario
    const updatedMessages = conversation.messages.slice(0, messageIndex + 1);
    
    // Actualizar la conversación sin las respuestas eliminadas
    const updatedConversation = {
      ...conversation,
      messages: updatedMessages,
      updatedAt: new Date().toISOString()
    };

    setConversations(prev => [
      updatedConversation,
      ...prev.filter(c => c.id !== conversationId)
    ]);
    setCurrentConversation(updatedConversation);

    // Regenerar la respuesta
    await sendMessage(
      updatedMessages[messageIndex].content,
      conversation.modelId,
      conversationId
    );
  };

  const value = {
    conversations,
    currentConversation,
    setCurrentConversation,
    setConversations,
    availableModels: networkModels,
    createNewConversation,
    deleteConversation,
    sendMessage,
    changeConversationModel,
    isLoading,
    isSaving,
    deleteMessage,
    editMessage,
    updateConversationTitle,
    regenerateResponse,
    chatConfig,
    updateChatConfig
  };

  return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>;
}

export function useChat() {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error('useChat must be used within a ChatProvider');
  }
  return context;
} 

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/contexts/NetworkContext.jsx ---
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react'
import { toast } from 'react-hot-toast'
import axios from 'axios';

const NetworkContext = createContext()

export function NetworkProvider({ children }) {
  const [isConnected, setIsConnected] = useState(false)
  const [localModels, setLocalModels] = useState([])
  const [networkModels, setNetworkModels] = useState([])
  const [isDetecting, setIsDetecting] = useState(false)
  const [balance, setBalance] = useState(0)
  const [activity, setActivity] = useState([])
  const [tokenStats, setTokenStats] = useState({
    tokensPerMinute: 0,
    tokensPerSecond: 0,
    lastUpdate: Date.now()
  })

  // Token stats calculation
  const updateTokenStats = useCallback((newActivity) => {
    if (!newActivity || !newActivity.tokens) return;
    
    setTokenStats(prev => {
      const now = Date.now();
      const timeWindow = 60000; // 1 minute in milliseconds
      const secondWindow = 1000; // 1 second in milliseconds
      
      // Calculate tokens per minute
      const tokensPerMinute = Math.round((newActivity.tokens.total || 0) * (timeWindow / (now - prev.lastUpdate)));
      
      // Calculate tokens per second
      const tokensPerSecond = Math.round((newActivity.tokens.total || 0) * (secondWindow / (now - prev.lastUpdate)));
      
      return {
        tokensPerMinute,
        tokensPerSecond,
        lastUpdate: now
      };
    });
  }, []);

  // Fetch models from the API with model comparison to prevent unnecessary updates
  const fetchNetworkModels = useCallback(async (silent = false) => {
    try {
      if (!silent) {
        console.log('Fetching network models...');
      }
      const apiKey = await window.electron.store.get('apiKey');
      const response = await axios.get(`${window.electron.config.API_URL}/v1/models`, {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Accept': 'application/json'
        }
      });
      
      if (response.data?.data) {
        // Compare new models with existing ones to prevent unnecessary updates
        const newModels = response.data.data;
        setNetworkModels(prevModels => {
          const hasChanges = JSON.stringify(prevModels) !== JSON.stringify(newModels);
          return hasChanges ? newModels : prevModels;
        });
      }
    } catch (error) {
      console.error('Failed to fetch network models:', error);
      if (!silent) {
        setNetworkModels([]);
      }
    }
  }, []);

  // Detect local LLM services with model comparison
  const detectLocalServices = useCallback(async (silent = false) => {
    if (!silent) {
      setIsDetecting(true);
    }
    try {
      const models = await window.electron.llm.detectServices();
      if (!silent) {
        console.log('Local models detected:', models);
      }
      
      // Compare new models with existing ones
      setLocalModels(prevModels => {
        const hasChanges = JSON.stringify(prevModels) !== JSON.stringify(models);
        return hasChanges ? models : prevModels;
      });
      
      if (models.length === 0 && isConnected) {
        await disconnect();
        if (!silent) {
          toast.error('Sharing disabled: No local LLM services detected');
        }
      }
    } catch (error) {
      console.error('Failed to detect local services:', error);
      if (!silent) {
        setLocalModels([]);
        if (isConnected) {
          await disconnect();
        }
      }
    } finally {
      if (!silent) {
        setIsDetecting(false);
      }
    }
  }, [isConnected]);

  const refreshModels = useCallback(async () => {
    console.log('Manually refreshing models...');
    setIsDetecting(true);
    await Promise.all([
      fetchNetworkModels(false),
      detectLocalServices(false)
    ]);
    setIsDetecting(false);
  }, [fetchNetworkModels, detectLocalServices]);

  // Check balance periodically with silent updates
  const checkBalance = useCallback(async (silent = true) => {
    try {
      const balanceData = await window.electron.auth.getBalance();
      if (!silent) {
        console.log('Balance data received:', balanceData);
      }
      if (balanceData && typeof balanceData.mule_balance !== 'undefined') {
        setBalance(balanceData.mule_balance);
      }
    } catch (error) {
      console.error('Failed to fetch balance:', error);
    }
  }, []);

  // Initialize and set up periodic checks
  useEffect(() => {
    console.log('NetworkProvider mounted, initializing...');
    
    // Initial checks
    refreshModels();
    checkBalance(false);
    
    // Add connection status listener
    window.electron.llm.onStatus(({ connected }) => {
      console.log('Connection status changed:', connected);
      setIsConnected(connected);
      if (!connected) {
        toast.error('Disconnected from network');
        // Reset token stats when disconnected
        setTokenStats({
          tokensPerMinute: 0,
          tokensPerSecond: 0,
          lastUpdate: Date.now()
        });
      }
    });

    // Add activity listener with token stats update
    window.electron.llm.onActivity((data) => {
      console.log('Activity:', data);
      setActivity(prev => [data, ...prev].slice(0, 50));
      updateTokenStats(data);
    });
    
    // Set up intervals for periodic checks with silent updates
    const balanceInterval = setInterval(() => checkBalance(true), 30000);
    const localModelInterval = setInterval(() => detectLocalServices(true), 30000);
    const networkModelInterval = setInterval(() => fetchNetworkModels(true), 30000);
    
    return () => {
      clearInterval(balanceInterval);
      clearInterval(localModelInterval);
      clearInterval(networkModelInterval);
    };
  }, [checkBalance, detectLocalServices, fetchNetworkModels, refreshModels, updateTokenStats]);

  const connect = async () => {
    try {
      if (!localModels.length) {
        throw new Error('No local models detected. Please make sure your LLM service is running.');
      }

      console.log('Connecting with models:', localModels);
      await window.electron.llm.connect(localModels);
      setIsConnected(true);
      toast.success('Connected to LLMule network');
      await checkBalance(false);
    } catch (error) {
      console.error('Connection error:', error);
      toast.error(error.message || 'Connection failed');
    }
  };

  const disconnect = async () => {
    try {
      await window.electron.llm.disconnect();
      setIsConnected(false);
      toast.success('Disconnected from network');
    } catch (error) {
      console.error('Disconnect error:', error);
      toast.error('Failed to disconnect from network');
    }
  };

  const value = {
    isConnected,
    setIsConnected,
    networkModels,
    models: networkModels, // For backward compatibility
    localModels,
    isDetecting,
    balance,
    activity: activity || [], // Ensure activity is always an array
    tokenStats, // Add tokenStats to context value
    refreshModels,
    connect,
    disconnect
  };

  return (
    <NetworkContext.Provider value={value}>
      {children}
    </NetworkContext.Provider>
  );
}

export const useNetwork = () => {
  const context = useContext(NetworkContext)
  if (!context) {
    throw new Error('useNetwork must be used within NetworkProvider')
  }
  return context
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/main.jsx ---
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './styles/index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,jsx}"
  ],
  theme: {
    extend: {
      fontFamily: {
        mono: ['Menlo', 'Monaco', 'Courier New', 'monospace']
      },
    },
  },
  plugins: [
    require('@tailwindcss/typography'),
  ],
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/vite.config.js ---
import { defineConfig } from 'vite'
import electron from 'vite-plugin-electron'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [
    react(),
    electron([
      {
        entry: 'electron/main.js',
        vite: {
          build: {
            outDir: 'dist-electron',
            rollupOptions: {
              external: ['electron', 'electron-store', 'electron-updater'],
              output: {
                format: 'cjs'
              }
            },
            minify: false
          }
        }
      },
      {
        entry: 'electron/preload.js',
        onstart(options) {
          options.reload()
        },
        vite: {
          build: {
            outDir: 'dist-electron',
            rollupOptions: {
              external: ['electron'],
              output: {
                format: 'cjs'
              }
            },
            minify: false
          }
        }
      }
    ])
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
})
