
--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/auth/handlers.js ---
import { ipcMain } from 'electron'
import axios from 'axios'
import Store from 'electron-store'
import config from '../config'

const store = new Store()

// Create axios instance with default config
const api = axios.create({
  baseURL: config.API_URL,
  timeout: 10000,
})

// Add request interceptor to log requests
api.interceptors.request.use(config => {
  console.log(`Making request to ${config.url} with baseURL ${config.baseURL}`)
  return config
})

// Add response interceptor to log responses
api.interceptors.response.use(
  response => {
    console.log(`Response from ${response.config.url}:`, response.status)
    return response
  },
  error => {
    console.error('API Error:', error.response?.data || error.message)
    throw error
  }
)

export function setupAuthHandlers() {
  ipcMain.handle('auth:register', async (_, email) => {
    try {
      const response = await api.post('/auth/register', { email })
      return response.data
    } catch (error) {
      console.error('Registration failed:', error.response?.data || error.message)
      throw new Error(error.response?.data?.message || 'Registration failed')
    }
  })

  ipcMain.handle('auth:checkVerification', async () => {
    try {
      const apiKey = store.get('apiKey')
      const response = await api.get('/auth/me', {
        headers: { Authorization: `Bearer ${apiKey}` }
      })
      return response.data.verified === true
    } catch (error) {
      console.error('Verification check failed:', error.response?.data || error.message)
      return false
    }
  })

  ipcMain.handle('auth:getStatus', async () => {
    const apiKey = store.get('apiKey')
    if (!apiKey) return { authenticated: false }

    try {
      const response = await api.get('/auth/me', {
        headers: { Authorization: `Bearer ${apiKey}` }
      })
      console.log('Auth status response:', response.data)
      
      return {
        authenticated: true,
        user: response.data
      }
    } catch (error) {
      console.error('Auth status check failed:', error.response?.data || error.message)
      return { authenticated: false }
    }
  })

  ipcMain.handle('auth:getBalance', async () => {
    const apiKey = store.get('apiKey')
    if (!apiKey) return { mule_balance: 0 }

    try {
      console.log('Fetching balance from:', `${config.API_URL}/v1/balance`)
      const response = await api.get('/v1/balance', {
        headers: { 
          Authorization: `Bearer ${apiKey}`,
          'Accept': 'application/json'
        }
      })
      console.log('Raw balance response:', response.data)
      return response.data
    } catch (error) {
      console.error('Balance check failed:', error.response?.data || error.message)
      if (error.response) {
        console.error('Error status:', error.response.status)
        console.error('Error headers:', error.response.headers)
      }
      return { mule_balance: 0 }
    }
  })
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/config.js ---
const config = {
    development: {
      API_URL: 'http://localhost:3000',
      WS_URL: 'ws://localhost:3000/llm-network'
    },
    production: {
      API_URL: 'https://api.llmule.xyz',
      WS_URL: 'wss://api.llmule.xyz/llm-network'
    }
  }
  
  // Force production environment by default
  const env = 'development' 
  console.log('Current environment:', env, 'using API:', config[env].API_URL)
  export default config[env]

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/llm/clients.js ---
import axios from 'axios';

class LLMClient {
  async generateCompletion(model, messages, options = {}) {
    throw new Error('Method not implemented');
  }
}

export class OllamaClient extends LLMClient {
  async generateCompletion(model, messages, options = {}) {
    try {
      const response = await axios.post('http://localhost:11434/api/chat', {
        model,
        messages,
        stream: false,
        options: {
          temperature: options.temperature || 0.7,
          num_predict: options.max_tokens || 4096,
        }
      });

      const usage = {
        prompt_tokens: this._estimateTokenCount(messages),
        completion_tokens: this._estimateTokenCount([response.data.message]),
        total_tokens: 0
      };
      usage.total_tokens = usage.prompt_tokens + usage.completion_tokens;

      return {
        choices: [{
          message: {
            role: 'assistant',
            content: response.data.message.content
          },
          finish_reason: 'stop'
        }],
        usage
      };
    } catch (error) {
      throw new Error(`Ollama error: ${error.message}`);
    }
  }

  _estimateTokenCount(messages) {
    let totalChars = 0;
    messages.forEach(msg => {
      if (typeof msg === 'string') totalChars += msg.length;
      else if (msg.content) totalChars += msg.content.length;
    });
    return Math.ceil(totalChars / 4);
  }
}

export class LMStudioClient extends LLMClient {
  async generateCompletion(model, messages, options = {}) {
    try {
      const response = await axios.post(
        'http://localhost:1234/v1/chat/completions',
        {
          model,
          messages,
          temperature: options.temperature || 0.7,
          max_tokens: options.max_tokens || 4096,
          stream: false
        }
      );

      return {
        choices: response.data.choices,
        usage: response.data.usage || {
          prompt_tokens: 0,
          completion_tokens: 0,
          total_tokens: 0
        }
      };
    } catch (error) {
      throw new Error(`LM Studio error: ${error.message}`);
    }
  }
}

export class ExoClient extends LLMClient {
  async generateCompletion(model, messages, options = {}) {
    try {
      const response = await axios.post(
        'http://localhost:52415/v1/chat/completions',
        {
          model,
          messages,
          temperature: options.temperature || 0.7,
          max_tokens: options.max_tokens || 4096,
          stream: false
        }
      );

      return {
        choices: response.data.choices,
        usage: response.data.usage || {
          prompt_tokens: 0,
          completion_tokens: 0,
          total_tokens: 0
        }
      };
    } catch (error) {
      throw new Error(`EXO error: ${error.message}`);
    }
  }
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/llm/detector.js ---
import axios from 'axios'
import Store from 'electron-store'

const store = new Store()

export class ModelDetector {
  constructor() {
    this.config = {
      ollama: 'http://localhost:11434',
      lmstudio: 'http://localhost:1234/v1',
      exo: 'http://localhost:52415'
    }
  }

  async detectAll() {
    const services = await this.checkServices()
    const models = []

    if (services.ollama) {
      const ollamaModels = await this.detectOllamaModels()
      models.push(...ollamaModels)
    }

    if (services.lmstudio) {
      const lmstudioModels = await this.detectLMStudioModels()
      models.push(...lmstudioModels)
    }

    return models
  }

  async checkServices() {
    const services = {}
    for (const [name, url] of Object.entries(this.config)) {
      try {
        await axios.get(url)
        services[name] = true
      } catch {
        services[name] = false
      }
    }
    return services
  }

  async detectOllamaModels() {
    try {
      const response = await axios.get(`${this.config.ollama}/api/tags`)
      return response.data.models.map(model => ({
        name: model.name,
        type: 'ollama',
        details: model
      }))
    } catch {
      return []
    }
  }

  async detectLMStudioModels() {
    try {
      const response = await axios.get(`${this.config.lmstudio}/models`)
      return response.data.data.map(model => ({
        name: model.id,
        type: 'lmstudio'
      }))
    } catch {
      return []
    }
  }
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/llm/handlers.js ---
import { ipcMain } from 'electron'
import { ModelDetector } from './detector'
import { NetworkClient } from './network'

let networkClient = null;
const detector = new ModelDetector();

export function setupLLMHandlers() {
  ipcMain.handle('llm:detect', async () => {
    return await detector.detectAll();
  });

  ipcMain.handle('llm:connect', async (_, models) => {
    try {
      if (!networkClient) networkClient = new NetworkClient();
      if (!models || !models.length) {
        throw new Error('No models provided for connection');
      }
      await networkClient.connect(models);
      return { success: true };
    } catch (error) {
      console.error('Connection failed:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('llm:disconnect', async () => {
    try {
      if (networkClient) {
        await networkClient.disconnect();
        networkClient = null;
      }
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  });
}

function sendToRenderer(channel, data) {
  if (global.mainWindow) {
    global.mainWindow.webContents.send(channel, data)
  }
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/llm/network.js ---
import WebSocket from 'ws'
import axios from 'axios'
import config from '../config'
import { OllamaClient, LMStudioClient, ExoClient } from './clients'
import Store from 'electron-store'

const store = new Store()

export class NetworkClient {
  constructor() {
    this.ws = null;
    this.isConnected = false;
    this.lastPong = Date.now();
    this.heartbeatInterval = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.models = [];
  }

  async getUserInfo() {
    try {
      const apiKey = store.get('apiKey');
      const response = await axios.get(`${config.API_URL}/auth/me`, {
        headers: { 
          'Authorization': `Bearer ${apiKey}`,
          'Accept': 'application/json'
        }
      });
      return response.data;
    } catch (error) {
      console.error('Failed to get user info:', error);
      return null;
    }
  }

  setupHeartbeat() {
    if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);

    this.ws.on('ping', () => {
      try {
        this.ws.pong();
        this.lastPong = Date.now();
      } catch (error) {
        console.error('Error sending pong:', error);
      }
    });

    this.ws.on('pong', () => {
      this.lastPong = Date.now();
    });

    this.heartbeatInterval = setInterval(() => {
      if (Date.now() - this.lastPong > 45000) {
        console.log('Connection dead - reconnecting...');
        this.reconnect();
      }
    }, 15000);
  }

  async connect(models) {
    const apiKey = store.get('apiKey');
    if (!apiKey) throw new Error('No API key found');
    
    this.models = models;
    this.ws = new WebSocket(config.WS_URL, {
      headers: { 'Authorization': `Bearer ${apiKey}` }
    });

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('Connection timeout')), 15000);

      this.ws.on('open', async () => {
        clearTimeout(timeout);
        this.isConnected = true;
        this.reconnectAttempts = 0;
        this.setupHeartbeat();
        
        try {
          await this.register(models);
          resolve();
        } catch (error) {
          reject(error);
        }
      });

      this.ws.on('message', this.handleMessage.bind(this));
      
      this.ws.on('close', (code) => {
        this.isConnected = false;
        if (code !== 1000) this.reconnect();
      });

      this.ws.on('error', (error) => {
        console.error('WebSocket error:', error);
        reject(error);
      });
    });
  }

  async register(models) {
    try {
      const userInfo = await this.getUserInfo();
      if (!userInfo?.userId) throw new Error('Failed to get user info');

      const modelList = models || this.models || [];
      const apiKey = store.get('apiKey');

      if (!modelList.length) {
        console.error('No models available for registration');
        return;
      }

      const message = {
        type: 'register',
        apiKey: apiKey,
        models: modelList.map(m => m.name),
        userId: userInfo.userId,
        provider: userInfo.provider
      };

      console.log('Sending registration:', JSON.stringify({
        type: message.type,
        models: message.models,
        userId: message.userId,
        hasApiKey: !!message.apiKey
      }));

      this.ws.send(JSON.stringify(message));
    } catch (error) {
      console.error('Failed to register:', error);
    }
  }

  async handleMessage(data) {
    const message = JSON.parse(data);
    console.log('Received message:', message.type);

    switch (message.type) {
      case 'completion_request':
        await this.handleCompletionRequest(message);
        break;
      case 'registered':
        console.log('Successfully registered');
        break;
      case 'error':
        console.error('Server error:', message.error);
        break;
    }
  }

  async handleCompletionRequest(message) {
    const llmClients = {
      ollama: new OllamaClient(),
      lmstudio: new LMStudioClient(),
      exo: new ExoClient()
    };

    try {
      const model = this.models.find(m => m.name === message.model);
      if (!model) {
        throw new Error(`Model ${message.model} not available`);
      }

      // Log activity start
      if (global.mainWindow) {
        global.mainWindow.webContents.send('llm:activity', {
          type: 'completion_start',
          message: `Processing request for ${model.name}`,
          timestamp: Date.now()
        });
      }

      const client = llmClients[model.type];
      const response = await client.generateCompletion(
        model.name,
        message.messages,
        {
          temperature: message.temperature,
          max_tokens: message.max_tokens
        }
      );

      // Log successful completion
      if (global.mainWindow) {
        global.mainWindow.webContents.send('llm:activity', {
          type: 'completion_success',
          message: `Completed request for ${model.name}`,
          timestamp: Date.now(),
          tokens: response.usage
        });
      }

      this.ws.send(JSON.stringify({
        type: 'completion_response',
        requestId: message.requestId,
        response
      }));

    } catch (error) {
      // Log error
      if (global.mainWindow) {
        global.mainWindow.webContents.send('llm:activity', {
          type: 'completion_error',
          message: `Error: ${error.message}`,
          timestamp: Date.now()
        });
      }

      this.ws.send(JSON.stringify({
        type: 'completion_response',
        requestId: message.requestId,
        response: {
          error: {
            message: error.message,
            type: "provider_error",
            code: "completion_failed"
          }
        }
      }));
    }
  }

  async disconnect() {
    if (this.ws) {
      this.ws.close(1000, 'Client disconnecting');
    }
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
    }
    this.isConnected = false;
  }

  async reconnect() {
    this.reconnectAttempts++;
    if (this.reconnectAttempts <= this.maxReconnectAttempts) {
      await new Promise(r => setTimeout(r, 5000));
      try {
        await this.connect();
      } catch (error) {
        console.error('Reconnection failed:', error);
      }
    }
  }
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/main.js ---
import { app, BrowserWindow, ipcMain } from 'electron'
import path from 'path'
import Store from 'electron-store'
import { setupAuthHandlers } from './auth/handlers.js'
import { setupLLMHandlers } from './llm/handlers.js'
import config from './config.js'
import { fileURLToPath } from 'url'


const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Environment setup
process.env.NODE_ENV = process.env.NODE_ENV || 'development'
process.env.API_URL = config.API_URL
console.log('Using API URL:', process.env.API_URL)

const store = new Store()
let mainWindow = null
// Add this function before createWindow
function getIconPath() {
  if (process.platform === 'darwin') {
    return path.join(process.resourcesPath, 'assets', 'icon.icns')
  }
  return path.join(process.resourcesPath, 'assets', 'icon.png')
}

const createWindow = () => {
  mainWindow = new BrowserWindow({
    width: 900,
    height: 680,
    minWidth: 800,
    minHeight: 600,
    icon: getIconPath(), 
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    }
  })

  if (process.env.VITE_DEV_SERVER_URL) {
    mainWindow.loadURL(process.env.VITE_DEV_SERVER_URL)
    mainWindow.webContents.openDevTools()
  } else {
    mainWindow.loadFile('dist/index.html')
  }

  // Make mainWindow available globally for event forwarding
  global.mainWindow = mainWindow
}

app.whenReady().then(() => {
  createWindow()
  setupAuthHandlers()
  setupLLMHandlers()
  
  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit()
})

// IPC Handlers
ipcMain.handle('store:get', (_, key) => {
  return store.get(key)
})

ipcMain.handle('store:set', (_, key, value) => {
  store.set(key, value)
  return true
})

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/preload.js ---
const { contextBridge, ipcRenderer } = require('electron')

// Set up activity event listener
let activityCallback = null;
ipcRenderer.on('llm:activity', (_, data) => {
  if (activityCallback) activityCallback(data);
});

contextBridge.exposeInMainWorld('electron', {
  store: {
    get: (key) => ipcRenderer.invoke('store:get', key),
    set: (key, value) => ipcRenderer.invoke('store:set', key, value),
  },
  auth: {
    register: (email) => ipcRenderer.invoke('auth:register', email),
    checkVerification: () => ipcRenderer.invoke('auth:checkVerification'),
    getStatus: () => ipcRenderer.invoke('auth:getStatus'),
    getBalance: () => ipcRenderer.invoke('auth:getBalance')
  },
  llm: {
    detectServices: () => ipcRenderer.invoke('llm:detect'),
    getModels: () => ipcRenderer.invoke('llm:models'),
    connect: (models) => ipcRenderer.invoke('llm:connect', models),
    disconnect: () => ipcRenderer.invoke('llm:disconnect'),
    onActivity: (callback) => {
      activityCallback = callback;
    }
  }
})

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/tray.js ---
import { Tray, Menu, app } from 'electron'
import path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

export class SystemTray {
  constructor(window) {
    this.window = window
    this.tray = null
  }

  create() {
    this.tray = new Tray(path.join(__dirname, '../assets/tray-icon.png'))
    this.tray.setToolTip('LLMule Desktop')
    this.updateMenu()
  }

  updateMenu(isConnected = false) {
    const contextMenu = Menu.buildFromTemplate([
      { label: 'LLMule Desktop', enabled: false },
      { type: 'separator' },
      {
        label: isConnected ? 'Stop Sharing' : 'Start Sharing',
        click: () => {
          this.window.webContents.send('tray:toggle-sharing')
        }
      },
      { type: 'separator' },
      {
        label: 'Show Window',
        click: () => {
          this.window.show()
        }
      },
      {
        label: 'Quit',
        click: () => {
          app.quit()
        }
      }
    ])

    this.tray.setContextMenu(contextMenu)
  }

  destroy() {
    if (this.tray) {
      this.tray.destroy()
    }
  }
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/electron/updater.js ---
import { autoUpdater } from 'electron-updater'
import { dialog } from 'electron'

export function setupAutoUpdater(window) {
  autoUpdater.autoDownload = false
  
  autoUpdater.on('error', (error) => {
    dialog.showErrorBox('Error', error.message)
  })

  autoUpdater.on('update-available', async () => {
    const response = await dialog.showMessageBox({
      type: 'info',
      title: 'Update Available',
      message: 'A new version of LLMule Desktop is available. Would you like to download it now?',
      buttons: ['Yes', 'No']
    })

    if (response.response === 0) {
      autoUpdater.downloadUpdate()
    }
  })

  autoUpdater.on('update-downloaded', async () => {
    const response = await dialog.showMessageBox({
      type: 'info',
      title: 'Update Ready',
      message: 'Install the update now?',
      buttons: ['Yes', 'Later']
    })

    if (response.response === 0) {
      autoUpdater.quitAndInstall()
    }
  })

  // Check for updates
  autoUpdater.checkForUpdates()
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/eslint.config.js ---
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]


--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/package.json ---
{
  "name": "llmule-desktop",
  "private": true,
  "version": "0.0.1",
  "description": "LLMule Desktop - Decentralized AI Computing",
  "author": {
    "name": "Andrés Cufari",
    "email": "andres@cm64.studio"
  },
  "type": "module",
  "main": "dist-electron/main.js",
  "scripts": {
    "dev": "vite",
    "start": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "electron:dev": "vite build && electron .",
    "electron:build": "electron-builder build --mac --config electron-builder.json",
    "package:mac": "npm run build && npm run electron:build",
    "package:mac-arm64": "npm run build && electron-builder build --mac --arm64 --config electron-builder.json",
    "package:mac-x64": "npm run build && electron-builder build --mac --x64 --config electron-builder.json",
    "package:mac-universal": "npm run build && electron-builder build --mac --universal --config electron-builder.json"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.0",
    "@heroicons/react": "^2.2.0",
    "autoprefixer": "^10.4.20",
    "axios": "^1.7.9",
    "bufferutil": "^4.0.9",
    "electron-store": "^10.0.0",
    "electron-updater": "^6.3.9",
    "postcss": "^8.4.49",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hot-toast": "^2.5.1",
    "tailwindcss": "^3.4.17",
    "utf-8-validate": "^6.0.5",
    "vite-plugin-electron": "^0.29.0",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "concurrently": "^9.1.2",
    "electron": "^33.2.1",
    "electron-builder": "^25.1.8",
    "eslint": "^9.17.0",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "vite": "^6.0.5",
    "wait-on": "^8.0.1"
  }
}


--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/postcss.config.js ---
import tailwindcss from 'tailwindcss'
import autoprefixer from 'autoprefixer'

export default {
  plugins: {
    tailwindcss,
    autoprefixer,
  },
}


--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/App.jsx ---
import React, { useState, useEffect } from 'react'
import { Toaster } from 'react-hot-toast'
import { NetworkProvider } from './contexts/NetworkContext'
import MainLayout from './components/layouts/MainLayout'
import StatusBar from './components/StatusBar'
import ModelList from './components/ModelList'
import ActivityLog from './components/ActivityLog'
import NetworkStats from './components/NetworkStats'
import AuthScreen from './components/auth/AuthScreen'

function App() {
  const [authStatus, setAuthStatus] = useState({ loading: true, authenticated: false })

  useEffect(() => {
    checkAuth()
  }, [])

  const checkAuth = async () => {
    try {
      const apiKey = await window.electron.store.get('apiKey')
      if (!apiKey) {
        setAuthStatus({ loading: false, authenticated: false })
        return
      }
      
      // Get auth status from the server
      const status = await window.electron.auth.getStatus()
      setAuthStatus({ loading: false, authenticated: status.authenticated })
      
      if (!status.authenticated) {
        // Clear invalid API key
        await window.electron.store.set('apiKey', null)
      }
    } catch (error) {
      console.error('Auth check failed:', error)
      setAuthStatus({ loading: false, authenticated: false })
      // Clear API key on error
      await window.electron.store.set('apiKey', null)
    }
  }

  if (authStatus.loading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-gray-400">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-400 mx-auto mb-4"></div>
          <div>Loading...</div>
        </div>
      </div>
    )
  }

  if (!authStatus.authenticated) {
    return <AuthScreen />
  }

  return (
    <NetworkProvider>
      <div className="min-h-screen bg-gray-900 text-white flex flex-col">
        {/* Header */}
        <header className="fixed top-0 left-0 right-0 z-10 bg-gray-900 border-b border-gray-800">
          <MainLayout>
            <StatusBar />
          </MainLayout>
        </header>

        {/* Main Content */}
        <main className="flex-1 mt-[65px] mb-[120px]"> {/* Adjust mt/mb based on header/footer height */}
          <div className="mx-auto w-full h-full p-4">
            <div className="space-y-4">
              <div className="bg-gray-800 rounded-lg p-4">
                <ModelList />
              </div>
              <div className="bg-gray-800 rounded-lg p-4">
                <ActivityLog />
              </div>
            </div>
          </div>
        </main>

        {/* Footer */}
        <footer className="fixed bottom-0 left-0 right-0 z-10 bg-gray-900 border-t border-gray-800">
          <div className="text-center text-gray-400 text-sm py-4">
            🦾 LLMule Network - Decentralizing AI
          </div>
          <NetworkStats />
        </footer>
      </div>
      <Toaster 
        position="bottom-right"
        toastOptions={{
          style: {
            background: '#1f2937',
            color: '#fff',
            borderRadius: '8px',
            border: '1px solid #374151'
          }
        }}
      />
    </NetworkProvider>
  )
}

export default App

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/ActivityLog.jsx ---
import React from 'react'
import { useNetwork } from '../contexts/NetworkContext'

export default function ActivityLog() {
  const { activity } = useNetwork()

  const getActivityIcon = (type) => {
    switch (type) {
      case 'completion_start':
        return '⏳'
      case 'completion_success':
        return '✅'
      case 'completion_error':
        return '❌'
      default:
        return '📝'
    }
  }

  return (
    <div className="flex flex-col">
      <h2 className="text-xl text-white mb-4">Activity Log</h2>
      
      <div className="flex-1 overflow-y-auto min-h-0 font-mono">
        {activity.length === 0 ? (
          <div className="text-gray-400 text-center py-8">
            <p>No activity yet</p>
            <p className="text-sm mt-2">Start sharing to see requests</p>
          </div>
        ) : (
          <div className="space-y-1">
            {activity.map((log, index) => (
              <div 
                key={index}
                className="bg-gray-800/50 hover:bg-gray-800 transition-colors rounded-md px-3 py-2 text-sm"
              >
                <div className="flex items-start gap-2">
                  <span className="text-gray-400 select-none">{getActivityIcon(log.type)}</span>
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <span className="text-green-400">{log.type}</span>
                      <span className="text-gray-500 text-xs">
                        {new Date(log.timestamp).toLocaleTimeString()}
                      </span>
                    </div>
                    <p className="text-gray-300 break-all">{log.message}</p>
                    {log.tokens && (
                      <p className="text-gray-500 text-xs mt-1">
                        Tokens: {log.tokens.total_tokens} (prompt: {log.tokens.prompt_tokens}, completion: {log.tokens.completion_tokens})
                      </p>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/ModelList.jsx ---
import React from 'react'
import { useNetwork } from '../contexts/NetworkContext'
import { ArrowPathIcon } from '@heroicons/react/24/solid'

export default function ModelList() {
  const { models, isDetecting, detectServices } = useNetwork()

  return (
    <div className="flex flex-col">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl text-white">Local Available Models</h2>
        <button
          onClick={detectServices}
          disabled={isDetecting}
          className="px-3 py-1 rounded-md bg-gray-700 hover:bg-gray-600 text-gray-300 flex items-center gap-2 text-sm"
        >
          <ArrowPathIcon 
            className={`w-4 h-4 ${isDetecting ? 'animate-spin' : ''}`} 
          />
          <span>Refresh</span>
        </button>
      </div>

      <div className="flex-1 overflow-y-auto min-h-0">
        {models.length === 0 ? (
          <div className="text-center py-8">
            <div className="text-4xl mb-4">⚠️</div>
            <p className="text-gray-400 mb-2">No LLM services detected</p>
            <p className="text-sm text-gray-500 mb-4">Install Ollama, LM Studio, or EXO</p>
          </div>
        ) : (
          <div className="space-y-1">
            {models.map((model) => (
              <div 
                key={`${model.type}-${model.name}`}
                className="bg-gray-700/50 hover:bg-gray-700 transition-colors rounded-md p-3 flex justify-between items-center"
              >
                <div>
                  <h3 className="text-white font-mono text-sm">{model.name}</h3>
                  <p className="text-gray-400 text-xs">via {model.type}</p>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-2 h-2 rounded-full bg-green-500" />
                  <span className="text-gray-400 text-xs">Ready</span>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/NetworkStats.jsx ---
import React from 'react'
import { useNetwork } from '../contexts/NetworkContext'
import { ArrowUpIcon, ArrowDownIcon } from '@heroicons/react/24/solid'

export default function NetworkStats() {
  const { balance, tokenStats, isConnected } = useNetwork()

  return (
    <div className="bg-gray-900 border-t border-gray-800 p-4">
      <div className="flex justify-between items-center">
        <div className="flex items-center gap-6">
          {isConnected && (
            <>
              <div className="flex items-center gap-2">
                <ArrowUpIcon className="w-4 h-4 text-green-500" />
                <span className="text-gray-400 text-sm">
                  {tokenStats.tokensPerMinute > 0 
                    ? `Processing: ${tokenStats.tokensPerMinute} tokens/min`
                    : 'Waiting for requests...'}
                </span>
              </div>
              {tokenStats.tokensPerMinute > 0 && (
                <div className="flex items-center gap-2">
                  <ArrowDownIcon className="w-4 h-4 text-blue-500" />
                  <span className="text-gray-400 text-sm">Rate: {tokenStats.tokensPerSecond} tokens/sec</span>
                </div>
              )}
            </>
          )}
        </div>
        
        <div className="flex items-center gap-4">
          <div className="text-sm">
            <span className="text-gray-400">Balance: </span>
            <span className="text-white font-mono">{Number(balance).toFixed(6)} MULE</span>
          </div>
        </div>
      </div>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/StatusBar.jsx ---
import React from 'react'
import { useNetwork } from '../contexts/NetworkContext'
import { Switch } from '@headlessui/react'

export default function StatusBar() {
  const { isConnected, connect, disconnect, isDetecting, models } = useNetwork()
  const hasModels = models.length > 0

  const toggleConnection = async () => {
    if (isConnected) {
      await disconnect()
    } else {
      await connect(models)
    }
  }

  return (
    <div className="flex items-center gap-3">
      <span className="text-gray-400 text-sm">Share</span>
      <Switch
        checked={isConnected}
        onChange={toggleConnection}
        disabled={isDetecting || (!hasModels && !isConnected)}
        title={!hasModels && !isConnected ? 'No models available to share' : ''}
        className={`${
          isConnected ? 'bg-green-600' : 'bg-gray-700'
        } relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed`}
      >
        <span
          className={`${
            isConnected ? 'translate-x-6' : 'translate-x-1'
          } inline-block h-4 w-4 transform rounded-full bg-white transition-transform`}
        />
      </Switch>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/auth/AuthScreen.jsx ---
import React, { useState } from 'react'
import toast from 'react-hot-toast'

export default function AuthScreen() {
  const [apiKey, setApiKey] = useState('')
  const [email, setEmail] = useState('')
  const [isRequestingKey, setIsRequestingKey] = useState(false)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState('')

  const handleSubmitApiKey = async (e) => {
    e.preventDefault()
    setIsLoading(true)
    setError('')
    
    if (!apiKey.trim()) {
      setError('Please enter an API key')
      setIsLoading(false)
      return
    }

    try {
      // First store the API key
      await window.electron.store.set('apiKey', apiKey)
      
      // Then validate it
      const isValid = await window.electron.auth.getStatus()
      
      if (!isValid.authenticated) {
        throw new Error('Invalid API key')
      }
      
      toast.success('Successfully connected!')
      window.location.reload()
    } catch (error) {
      const message = error.message || 'Failed to validate API key'
      toast.error(message)
      setError(message)
      // Clear invalid API key
      await window.electron.store.set('apiKey', null)
    } finally {
      setIsLoading(false)
    }
  }

  const handleRequestKey = async (e) => {
    e.preventDefault()
    setIsLoading(true)
    setError('')

    if (!email.trim()) {
      setError('Please enter your email')
      setIsLoading(false)
      return
    }

    try {
      await window.electron.auth.register(email)
      toast.success('Check your email for your API key')
      setIsRequestingKey(false)
    } catch (error) {
      const message = error.message || 'Failed to request API key'
      toast.error(message)
      setError(message)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="min-h-screen bg-gray-900 flex items-center justify-center p-4">
      <div className="w-full max-w-md space-y-8">
        <div className="text-center">
          <h1 className="text-2xl font-bold text-white">Welcome to LLMule</h1>
          <p className="mt-2 text-gray-400">Share your LLMs with the world</p>
        </div>

        {!isRequestingKey ? (
          <>
            <form onSubmit={handleSubmitApiKey} className="mt-8 space-y-6">
              <div>
                <label htmlFor="apiKey" className="block text-sm font-medium text-gray-400">
                  API Key
                </label>
                <input
                  type="text"
                  value={apiKey}
                  onChange={(e) => setApiKey(e.target.value)}
                  className={`mt-1 block w-full rounded-md bg-gray-800 border ${
                    error ? 'border-red-500' : 'border-gray-700'
                  } text-white px-3 py-2`}
                  placeholder="llm_..."
                  disabled={isLoading}
                />
                {error && <p className="mt-1 text-sm text-red-500">{error}</p>}
              </div>
              <button
                type="submit"
                disabled={isLoading}
                className="w-full py-2 px-4 rounded-md text-white bg-indigo-600 hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isLoading ? 'Connecting...' : 'Connect'}
              </button>
              <button
                type="button"
                onClick={() => setIsRequestingKey(true)}
                disabled={isLoading}
                className="w-full py-2 text-sm text-gray-400 hover:text-white disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Need an API key?
              </button>
            </form>
          </>
        ) : (
          <form onSubmit={handleRequestKey} className="mt-8 space-y-6">
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-400">
                Email
              </label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className={`mt-1 block w-full rounded-md bg-gray-800 border ${
                  error ? 'border-red-500' : 'border-gray-700'
                } text-white px-3 py-2`}
                placeholder="you@example.com"
                disabled={isLoading}
              />
              {error && <p className="mt-1 text-sm text-red-500">{error}</p>}
            </div>
            <button
              type="submit"
              disabled={isLoading}
              className="w-full py-2 px-4 rounded-md text-white bg-indigo-600 hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isLoading ? 'Requesting...' : 'Request API Key'}
            </button>
            <button
              type="button"
              onClick={() => setIsRequestingKey(false)}
              disabled={isLoading}
              className="w-full py-2 text-sm text-gray-400 hover:text-white disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Back to login
            </button>
          </form>
        )}
      </div>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/components/layouts/MainLayout.jsx ---
import React, { useState, useEffect, Fragment } from 'react'
import { useNetwork } from '../../contexts/NetworkContext'
import { Menu, Transition } from '@headlessui/react'
import { ChevronDownIcon, ArrowRightOnRectangleIcon } from '@heroicons/react/24/solid'

export default function MainLayout({ children }) {
  const { isConnected, tokenStats } = useNetwork()
  const [userEmail, setUserEmail] = useState('')

  useEffect(() => {
    const getUserInfo = async () => {
      try {
        const status = await window.electron.auth.getStatus()
        if (status.authenticated && status.user) {
          setUserEmail(status.user.email)
        }
      } catch (error) {
        console.error('Failed to get user info:', error)
      }
    }
    getUserInfo()
  }, [])

  const handleLogout = async () => {
    await window.electron.store.set('apiKey', null)
    window.location.reload()
  }

  return (
    <div className="p-4 flex items-center">
      <div className="flex-1 flex items-center gap-4">
        <h1 className="text-xl font-mono">⚡ LLMule</h1>
        
        <div className="flex items-center gap-2 px-3 py-1 rounded-full bg-gray-800">
          <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
          <span className="text-gray-400 text-sm">
            {isConnected ? 'Connected to Network' : 'Disconnected'}
          </span>
        </div>
      </div>

      <div className="flex items-center gap-4">
        <Menu as="div" className="relative">
          <Menu.Button className="flex items-center gap-2 px-3 py-1 rounded-full bg-gray-800 hover:bg-gray-700 transition-colors">
            <span className="text-gray-300 text-sm">{userEmail}</span>
            <ChevronDownIcon className="w-4 h-4 text-gray-400" />
          </Menu.Button>
          
          <Transition
            as={Fragment}
            enter="transition ease-out duration-100"
            enterFrom="transform opacity-0 scale-95"
            enterTo="transform opacity-100 scale-100"
            leave="transition ease-in duration-75"
            leaveFrom="transform opacity-100 scale-100"
            leaveTo="transform opacity-0 scale-95"
          >
            <Menu.Items className="absolute right-0 mt-2 w-48 rounded-md bg-gray-800 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none">
              <Menu.Item>
                {({ active }) => (
                  <button
                    onClick={handleLogout}
                    className={`${
                      active ? 'bg-gray-700' : ''
                    } group flex w-full items-center px-4 py-2 text-sm text-gray-300`}
                  >
                    <ArrowRightOnRectangleIcon className="mr-3 h-5 w-5 text-gray-400" />
                    Logout
                  </button>
                )}
              </Menu.Item>
            </Menu.Items>
          </Transition>
        </Menu>

        <div className="flex justify-end">
          {children}
        </div>
      </div>
    </div>
  )
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/contexts/NetworkContext.jsx ---
import React, { createContext, useContext, useState, useEffect } from 'react'
import { toast } from 'react-hot-toast'

const NetworkContext = createContext()

export function NetworkProvider({ children }) {
  const [isConnected, setIsConnected] = useState(false)
  const [models, setModels] = useState([])
  const [activeModels, setActiveModels] = useState([])
  const [balance, setBalance] = useState(0)
  const [activity, setActivity] = useState([])
  const [isDetecting, setIsDetecting] = useState(false)
  const [tokenStats, setTokenStats] = useState({ tokensPerMinute: 0, tokensPerSecond: 0 })

  useEffect(() => {
    detectServices()
    checkBalance() // Check balance immediately on mount
    
    // Set up periodic checks
    const balanceInterval = setInterval(checkBalance, 30000) // every 30 seconds
    const modelInterval = setInterval(checkModels, 5000) // check models every 5 seconds
    
    // Set up activity listener
    window.electron.llm.onActivity((data) => {
      setActivity(prev => {
        const newActivity = [data, ...prev].slice(0, 50);
        updateTokenStats(newActivity);
        return newActivity;
      });
    });

    return () => {
      clearInterval(balanceInterval)
      clearInterval(modelInterval)
    }
  }, [])

  // Check for model changes
  const checkModels = async () => {
    if (isDetecting) return; // Skip if already detecting

    try {
      const newModels = await window.electron.llm.detectServices()
      
      // Compare with current models
      const currentModelKeys = models.map(m => `${m.type}-${m.name}`).sort().join(',')
      const newModelKeys = newModels.map(m => `${m.type}-${m.name}`).sort().join(',')
      
      if (currentModelKeys !== newModelKeys) {
        console.log('Models changed. Current:', models, 'New:', newModels)
        setModels(newModels)
        
        // If connected and models changed or no models available, handle appropriately
        if (isConnected) {
          if (newModels.length === 0) {
            console.log('Disconnecting due to no available models')
            await disconnect()
            toast.error('Sharing disabled: No LLM services available')
          } else {
            console.log('Reconnecting due to model changes')
            await disconnect()
            await connect()
          }
        }
      }
    } catch (error) {
      console.error('Failed to check models:', error)
      // Disconnect on error if connected
      if (isConnected) {
        await disconnect()
        toast.error('Sharing disabled: Failed to detect LLM services')
      }
    }
  }

  const updateTokenStats = (activities) => {
    const now = Date.now();
    const lastMinute = now - 60000;
    const recentActivities = activities.filter(
      act => act.timestamp > lastMinute && act.type === 'completion_success'
    );

    const totalTokens = recentActivities.reduce(
      (sum, act) => sum + (act.tokens?.total_tokens || 0), 
      0
    );

    // Calculate tokens per second first
    const tokensPerSecond = totalTokens / 60;
    
    setTokenStats({
      tokensPerMinute: Math.round(tokensPerSecond * 60),
      tokensPerSecond: tokensPerSecond.toFixed(1)
    });
  }

  const checkBalance = async () => {
    try {
      const balanceData = await window.electron.auth.getBalance()
      console.log('Balance data received:', balanceData)
      if (balanceData && typeof balanceData.mule_balance !== 'undefined') {
        console.log('Setting new balance:', balanceData.mule_balance)
        setBalance(balanceData.mule_balance)
      } else {
        console.warn('Invalid balance data received:', balanceData)
      }
    } catch (error) {
      console.error('Failed to fetch balance:', error)
    }
  }

  const detectServices = async () => {
    setIsDetecting(true)
    try {
      const models = await window.electron.llm.detectServices()
      setModels(models)
      
      // If no models detected and we're connected, disconnect
      if (models.length === 0 && isConnected) {
        await disconnect()
        toast.error('Sharing disabled: No LLM services detected')
      } else {
        toast.success(`Found ${models.length} models`)
      }
    } catch (error) {
      toast.error('Failed to detect LLM services')
      // Also disconnect on error if connected
      if (isConnected) {
        await disconnect()
      }
    } finally {
      setIsDetecting(false)
    }
  }

  const connect = async () => {
    try {
      if (!models.length) {
        throw new Error('No models detected. Please make sure your LLM service is running.');
      }

      // Validate models have required properties
      const invalidModels = models.filter(m => !m.name || !m.type);
      if (invalidModels.length > 0) {
        throw new Error('Some models are invalid. Please try detecting models again.');
      }

      console.log('Connecting with models:', models);
      await window.electron.llm.connect(models);
      setIsConnected(true);
      toast.success('Connected to LLMule network');
      // Check balance immediately after connection
      await checkBalance();
    } catch (error) {
      console.error('Connection error:', error);
      toast.error(error.message || 'Connection failed');
    }
  }

  const disconnect = async () => {
    try {
      await window.electron.llm.disconnect()
      setIsConnected(false)
      toast.success('Disconnected from network')
    } catch (error) {
      console.error('Disconnect error:', error)
      toast.error('Failed to disconnect from network')
    }
  }

  const value = {
    isConnected,
    models,
    activeModels,
    balance,
    activity,
    isDetecting,
    tokenStats,
    detectServices,
    connect,
    disconnect
  }

  return (
    <NetworkContext.Provider value={value}>
      {children}
    </NetworkContext.Provider>
  )
}

export const useNetwork = () => {
  const context = useContext(NetworkContext)
  if (!context) {
    throw new Error('useNetwork must be used within NetworkProvider')
  }
  return context
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/src/main.jsx ---
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './styles/index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,jsx}"
  ],
  theme: {
    extend: {
      fontFamily: {
        mono: ['Menlo', 'Monaco', 'Courier New', 'monospace']
      },
    },
  },
  plugins: [],
}

--- /Users/andrescufari/DEUS/cm64/MIT/llmule-desktop/vite.config.js ---
import { defineConfig } from 'vite'
import electron from 'vite-plugin-electron'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [
    react(),
    electron([
      {
        entry: 'electron/main.js',
        vite: {
          build: {
            outDir: 'dist-electron',
            rollupOptions: {
              external: ['electron', 'electron-store', 'electron-updater'],
              output: {
                format: 'cjs'
              }
            },
            minify: false
          }
        }
      },
      {
        entry: 'electron/preload.js',
        onstart(options) {
          options.reload()
        },
        vite: {
          build: {
            outDir: 'dist-electron',
            rollupOptions: {
              external: ['electron'],
              output: {
                format: 'cjs'
              }
            },
            minify: false
          }
        }
      }
    ])
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
})
